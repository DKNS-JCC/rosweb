<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control Admin de Robot - artTEC</title>
    <link rel="icon" type="image/x-icon" href="icon.ico">
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/roslib@1.3.0/build/roslib.min.js"></script>
    <script src="https://unpkg.com/three@0.145.0/build/three.min.js"></script>
    <style>
        /* Estilos para men√∫ m√≥vil de usuario y autenticaci√≥n */
        .nav-mobile-user,
        .nav-mobile-auth {
            display: none !important;
        }

        @media screen and (max-width: 768px) {
            .nav-mobile-user,
            .nav-mobile-auth {
                display: block !important;
            }

            .nav-mobile-divider {
                height: 1px;
                background: linear-gradient(90deg, transparent, #e9ecef, transparent);
                margin: 15px 20px;
            }

            .nav-mobile-user-info {
                padding: 10px 20px;
                text-align: center;
                background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
                margin: 0 20px;
                border-radius: 8px;
                border-left: 4px solid #4129ca;
            }

            .nav-mobile-username {
                font-weight: 600;
                color: #4129ca;
                font-size: 16px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
            }

            .nav-mobile-username::before {
                content: "üë§";
                font-size: 18px;
            }

            .nav-mobile-profile,
            .nav-mobile-logout {
                display: flex !important;
                align-items: center;
                justify-content: center;
                gap: 10px;
                background: none;
                border: none;
                width: 100%;
                text-decoration: none;
                font-size: 15px;
                font-weight: 500;
                transition: all 0.3s ease;
            }

            .nav-mobile-profile {
                color: #4129ca;
            }

            .nav-mobile-profile:hover {
                background: rgba(65, 41, 202, 0.1);
                color: #4129ca;
            }

            .nav-mobile-logout {
                color: #dc3545;
                cursor: pointer;
            }

            .nav-mobile-logout:hover {
                background: rgba(220, 53, 69, 0.1);
                color: #dc3545;
            }

            .nav-mobile-profile svg,
            .nav-mobile-logout svg {
                flex-shrink: 0;
            }

            /* Botones de autenticaci√≥n en m√≥vil */
            .nav-mobile-auth-buttons {
                display: flex;
                flex-direction: column;
                gap: 10px;
                padding: 0 20px;
            }

            .nav-mobile-auth-btn {
                padding: 12px 20px;
                text-align: center;
                text-decoration: none;
                border-radius: 8px;
                font-weight: 600;
                transition: all 0.3s ease;
            }

            .nav-mobile-login {
                background: transparent;
                color: #4129ca;
                border: 2px solid #4129ca;
            }

            .nav-mobile-login:hover {
                background: #4129ca;
                color: white;
            }

            .nav-mobile-register {
                background: #4129ca;
                color: white;
                border: 2px solid #4129ca;
            }

            .nav-mobile-register:hover {
                background: #3a23b8;
                border-color: #3a23b8;
            }

            /* Ocultar dropdown de usuario en m√≥vil */
            .nav-user-dropdown {
                display: none;
            }

            .nav-user-info {
                display: none;
            }

            /* Ocultar botones de autenticaci√≥n del header en m√≥vil */
            .nav-auth-menu {
                display: none;
            }
        }

        .robot-container {
            min-width: 90%;
            margin: 0 auto;
            padding: 20px;
            background: white;
            min-height: 100vh;
        }
        
        .robot-header {
            background: #4129ca;
            color: white;
            padding: 20px;
            margin: -20px -20px 30px -20px;
            border-radius: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .robot-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .robot-title h1 {
            margin: 0;
            font-size: 1.8rem;
        }
        
        .robot-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 4px solid #4129ca;
        }
        
        .robot-section h2 {
            color: #4129ca;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .status-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-top: 4px solid #4129ca;
        }
        
        .status-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
        }
        
        .status-connected {
            background: #28a745;
        }
        
        .status-disconnected {
            background: #dc3545;
        }
        
        .control-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .movement-controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .movement-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 300px;
            margin: 0 auto;
        }
        
        .movement-btn {
            padding: 15px;
            border: none;
            border-radius: 8px;
            background: #4129ca;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .movement-btn:hover {
            background: #3a23b8;
        }
        
        .movement-btn:active {
            transform: scale(0.95);
        }
        
        .movement-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .sensor-data {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .topic-list {
            max-height: 300px;
            overflow-y: auto;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
        }
        
        .topic-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            font-family: monospace;
            font-size: 12px;
        }
        
        .topic-item:last-child {
            border-bottom: none;
        }
        
        .log-area {
            background: #1e1e1e;
            color: #fff;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            height: 200px;
            overflow-y: auto;
            margin-top: 15px;
        }
        
        .velocity-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        
        .velocity-item {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .velocity-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4129ca;
        }
        
        /* Controles de zoom con botones */
        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 10;
        }
        
        .zoom-btn {
            width: 35px;
            height: 35px;
            border: 2px solid #4129ca;
            background: white;
            color: #4129ca;
            font-size: 18px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .zoom-btn:hover {
            background: #4129ca;
            color: white;
            transform: scale(1.1);
        }
        
        .zoom-btn:active {
            transform: scale(0.95);
        }
        
        
        .robot-position {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
        }
        
        /* Estilos para Waypoints 3D */
        .waypoints-3d-container {
            border: 2px solid #4129ca;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            background: #f5f5f5;
        }
        
        .waypoints-controls {
            background: #4129ca;
            color: white;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .waypoints-controls button {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            background: white;
            color: #4129ca;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .waypoints-controls button:hover {
            background: #f0f0f0;
            transform: scale(1.05);
        }
        
        .waypoints-controls button:disabled {
            background: #ccc;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .waypoints-status {
            color: #ffeb3b;
            font-weight: bold;
            margin-left: auto;
        }
        
        /* Estilos espec√≠ficos para posici√≥n inicial */
        #setInitialPose3D {
            transition: background-color 0.3s, transform 0.2s;
        }
        
        #setInitialPose3D:hover {
            transform: translateY(-2px);
        }
        
        #initialPoseStatus3D {
            font-size: 0.9em;
            margin-top: 5px;
            padding: 5px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .map-3d-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 100;
            max-width: 200px;
        }
        
        #map3D {
            cursor: crosshair;
            display: block;
        }

        /* Estilos para la secci√≥n de c√°mara */
        .camera-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-top: 4px solid #4129ca;
        }

        .camera-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
        }

        .camera-stream {
            width: 100%;
            height: 450px;
            object-fit: cover;
            border-radius: 10px;
            display: block;
        }

        .camera-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
        }

        .camera-status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .camera-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #28a745;
        }

        .camera-indicator.disconnected {
            background: #dc3545;
        }

        .camera-error {
            display: none;
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 60px 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .camera-controls {
            margin-top: 15px;
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .camera-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background: #4129ca;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .camera-btn:hover {
            background: #3a23b8;
        }

        .camera-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Estilos para la secci√≥n de s√≠ntesis de voz */
        .speech-container {
            gap: 30px;
            align-items: start;
        }

        .speech-controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .speech-input-group {
            margin-bottom: 20px;
        }

        .speech-label {
            display: block;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
        }

        .speech-textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            line-height: 1.4;
            resize: vertical;
            min-height: 100px;
            transition: border-color 0.3s;
        }

        .speech-textarea:focus {
            outline: none;
            border-color: #4129ca;
            box-shadow: 0 0 0 3px rgba(65, 41, 202, 0.1);
        }

        .speech-counter {
            text-align: right;
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .speech-buttons {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .speech-btn {
            flex: 1;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: bold;
            border-radius: 6px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            border: none;
            cursor: pointer;
        }

        .speech-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .speech-presets {
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .preset-btn {
            padding: 8px 12px;
            border: 1px solid #ddd;
            background: #f8f9fa;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            text-align: center;
        }

        .preset-btn:hover {
            background: #e9ecef;
            border-color: #4129ca;
            transform: translateY(-1px);
        }

        .speech-status {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .speech-status h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #4129ca;
            font-size: 16px;
        }

        .status-indicator-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .speech-topic-info {
            margin-bottom: 20px;
            padding: 10px;
            background: #f0f8ff;
            border-radius: 4px;
            border-left: 3px solid #4129ca;
        }

        .speech-history-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 10px;
            background: #f8f9fa;
        }

        .speech-history-item {
            background: white;
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 4px;
            border-left: 3px solid #4129ca;
            font-size: 13px;
            line-height: 1.3;
        }

        .speech-history-item:last-child {
            margin-bottom: 0;
        }

        .speech-history-empty {
            text-align: center;
            color: #999;
            font-style: italic;
            margin: 20px 0;
        }

        .speech-history-time {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        /* Responsive para m√≥vil */
        @media (max-width: 768px) {
            .speech-container {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .speech-buttons {
                flex-direction: column;
            }
            
            .speech-btn {
                width: 100%;
            }
            
            .preset-buttons {
                grid-template-columns: 1fr;
            }
        }

        /* Estilos para el modal de zonas */
        .zones-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.8);
        }

        .zones-modal-content {
            background-color: #fefefe;
            margin: 2% auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 12px;
            width: 95%;
            max-width: 1200px;
            height: 90vh;
            max-height: 90vh;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .zones-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        .zones-modal-header h2 {
            margin: 0;
            color: #333;
        }

        .zones-close {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }

        .zones-close:hover {
            background: #c82333;
        }

        .zones-content {
            display: flex;
            gap: 20px;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .zones-map-container {
            flex: 3;
            position: relative;
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background: #f5f5f5;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .zones-map {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            display: block;
            flex: 1;
        }

        .zones-controls {
            flex: 1;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #eee;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .zones-controls h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            flex-shrink: 0;
        }

        .zone-form {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #ddd;
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        .zone-input-group {
            margin-bottom: 15px;
        }

        .zone-input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        .zone-input-group input,
        .zone-input-group select {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .zone-input-group input:focus,
        .zone-input-group select:focus {
            border-color: #4129ca;
            outline: none;
        }

        .zone-color-preview {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            border: 2px solid #ddd;
            margin-top: 5px;
        }

        .zone-buttons {
            display: flex;
            gap: 10px;
        }

        .zone-btn {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .zone-btn-primary {
            background: #4129ca;
            color: white;
        }

        .zone-btn-primary:hover {
            background: #3520b8;
        }

        .zone-btn-secondary {
            background: #6c757d;
            color: white;
        }

        .zone-btn-secondary:hover {
            background: #5a6268;
        }

        .zone-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .zones-list-container {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .zones-list-container h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            flex-shrink: 0;
        }

        .zones-list {
            flex: 1;
            overflow-y: auto;
            min-height: 200px;
            padding-right: 5px;
        }

        .zones-list::-webkit-scrollbar {
            width: 8px;
        }

        .zones-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .zones-list::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        .zones-list::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .zone-item {
            background: white;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .zone-info {
            flex: 1;
        }

        .zone-name {
            font-weight: bold;
            margin-bottom: 3px;
        }

        .zone-coords {
            font-size: 12px;
            color: #666;
        }

        .zone-color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #ccc;
            margin-right: 10px;
        }

        .zone-delete {
            background: #dc3545;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .zone-delete:hover {
            background: #c82333;
        }

        .zone-instructions {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #b3d9ff;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.5;
            flex-shrink: 0;
        }

        .zone-drawing {
            cursor: crosshair !important;
        }

        .zone-status {
            text-align: center;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-weight: bold;
            flex-shrink: 0;
        }

        .zone-status-info {
            background: #cce7ff;
            color: #0066cc;
        }

        .zone-status-success {
            background: #ccffcc;
            color: #006600;
        }

        .zone-status-error {
            background: #ffcccc;
            color: #cc0000;
        }

        /* Responsivo para dispositivos m√≥viles */
        @media screen and (max-width: 768px) {
            .zones-modal-content {
                width: 98%;
                height: 95vh;
                margin: 1% auto;
                padding: 10px;
            }

            .zones-content {
                flex-direction: column;
                gap: 15px;
            }

            .zones-map-container {
                flex: none;
                height: 300px;
                min-height: 300px;
            }

            .zones-controls {
                flex: none;
                max-height: 400px;
                overflow-y: auto;
            }

            .zones-list {
                min-height: 150px;
            }

            .zone-form {
                margin-bottom: 15px;
            }

            .zone-buttons {
                flex-direction: column;
                gap: 8px;
            }
        }

        @media screen and (max-width: 480px) {
            .zones-modal-content {
                width: 100%;
                height: 100vh;
                margin: 0;
                border-radius: 0;
            }

            .zones-map-container {
                height: 250px;
                min-height: 250px;
            }
        }

        /* Estilos para el panel de navegaci√≥n por zonas */
        .zone-navigation-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .zone-nav-controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 15px;
        }

        .zone-selector-group {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .zone-selector-group label {
            font-weight: 600;
            color: #333;
            min-width: 140px;
        }

        .zone-select {
            flex: 1;
            min-width: 200px;
            padding: 10px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        .zone-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .zone-select:disabled {
            background: #f8f9fa;
            color: #666;
            cursor: not-allowed;
        }

        .zone-nav-actions {
            display: flex;
            align-items: center;
            gap: 20px;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        .zone-nav-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #navStatusText {
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }

        .nav-status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #28a745;
            transition: all 0.3s ease;
        }

        .nav-status-ready .nav-status-indicator {
            background: #28a745;
        }

        .nav-status-navigating .nav-status-indicator {
            background: #ffc107;
            animation: pulse 1.5s infinite;
        }

        .nav-status-arrived .nav-status-indicator {
            background: #17a2b8;
        }

        .nav-status-error .nav-status-indicator {
            background: #dc3545;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .zone-info-panel {
            background: #f8f9fa;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .zone-info-panel h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 16px;
        }

        .zone-info-details p {
            margin: 8px 0;
            color: #555;
            font-size: 14px;
        }

        .zone-info-details strong {
            color: #333;
            min-width: 80px;
            display: inline-block;
        }

        /* Responsive para navegaci√≥n por zonas */
        @media screen and (max-width: 768px) {
            .zone-selector-group {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }

            .zone-selector-group label {
                min-width: auto;
            }

            .zone-select {
                min-width: auto;
            }

            .zone-nav-actions {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }

            .zone-nav-status {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <!-- Barra de navegaci√≥n fija -->
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <img src="icon.ico" alt="artTEC Logo" class="nav-logo-img">
                <span class="nav-logo-text">artTEC</span>
            </div>
            <ul class="nav-menu" id="navMenu">
                <li class="nav-item">
                    <a href="/" class="nav-link">Inicio</a>
                </li>
                <li class="nav-item">
                    <a href="/#tours" class="nav-link">Tours</a>
                </li>
                <li class="nav-item">
                    <a href="/#how-it-works" class="nav-link">C√≥mo Funciona</a>
                </li>
                <li class="nav-item">
                    <a href="/robot" class="nav-link" id="navRobotControl">Control Robot</a>
                </li>
                <li class="nav-item">
                    <a href="/admin" class="nav-link" id="navAdmin">Administraci√≥n</a>
                </li>
                <li class="nav-item">
                    <a href="/stats" class="nav-link" id="navStats">Estad√≠sticas</a>
                </li>
                
                <!-- Secci√≥n m√≥vil de usuario (solo visible en m√≥vil cuando est√° logueado) -->
                <li class="nav-item nav-mobile-user" id="navMobileUser" style="display: none;">
                    <div class="nav-mobile-divider"></div>
                    <div class="nav-mobile-user-info">
                        <div id="nav-mobile-username" class="nav-mobile-username"></div>
                    </div>
                </li>
                <li class="nav-item nav-mobile-user" id="navMobileProfile" style="display: none;">
                    <a href="/dashboard.html" class="nav-link nav-mobile-profile">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                        Mi Perfil
                    </a>
                </li>
                <li class="nav-item nav-mobile-user" id="navMobileLogout" style="display: none;">
                    <button class="nav-link nav-mobile-logout" id="navMobileLogoutBtn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>
                        Cerrar Sesi√≥n
                    </button>
                </li>
                
                <!-- Secci√≥n m√≥vil de autenticaci√≥n (solo visible en m√≥vil cuando NO est√° logueado) -->
                <li class="nav-item nav-mobile-auth" id="navMobileAuth">
                    <div class="nav-mobile-divider"></div>
                    <div class="nav-mobile-auth-buttons">
                        <a href="/login" class="nav-mobile-auth-btn nav-mobile-login">Iniciar Sesi√≥n</a>
                        <a href="/register" class="nav-mobile-auth-btn nav-mobile-register">Registrarse</a>
                    </div>
                </li>
            </ul>
            
            <!-- Secci√≥n de usuario -->
            <div class="nav-user-section">
                <!-- Men√∫ para usuarios no autenticados -->
                <div class="nav-auth-menu" id="navAuthMenu">
                    <a href="/login" class="nav-btn nav-btn-outline">Iniciar Sesi√≥n</a>
                    <a href="/register" class="nav-btn nav-btn-primary">Registrarse</a>
                </div>
                
                <!-- Men√∫ para usuarios autenticados -->
                <div class="nav-user-menu" id="navUserMenu" style="display: none;">
                    <div class="nav-user-info">
                        <span class="nav-username" id="navUsername">Usuario</span>
                    </div>
                    <div class="nav-user-dropdown">
                        <button class="nav-user-toggle" id="navUserToggle">
                            <img src="/favicon.ico" alt="Usuario" class="nav-user-avatar" id="navUserAvatar">
                            <svg class="nav-dropdown-arrow" width="12" height="12" viewBox="0 0 12 12">
                                <path d="M3 5L6 8L9 5" stroke="currentColor" fill="none" stroke-width="1.5"/>
                            </svg>
                        </button>
                        <div class="nav-dropdown-menu" id="navDropdownMenu">
                            <a href="/dashboard.html" class="nav-dropdown-item">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                                    <path d="M12 12C14.21 12 16 10.21 16 8C16 5.79 14.21 4 12 4C9.79 4 8 5.79 8 8C8 10.21 9.79 12 12 12ZM12 14C9.33 14 4 15.34 4 18V20H20V18C20 15.34 14.67 14 12 14Z" fill="currentColor"/>
                                </svg>
                                Mi Perfil
                            </a>
                            <button class="nav-dropdown-item" id="navLogoutBtn">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                                    <path d="M17 7L15.59 8.41L18.17 11H8V13H18.17L15.59 15.59L17 17L22 12L17 7ZM4 5H12V3H4C2.9 3 2 3.9 2 5V19C2 20.1 2.9 21 4 21H12V19H4V5Z" fill="currentColor"/>
                                </svg>
                                Cerrar Sesi√≥n
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="nav-toggle" id="navToggle">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>

    <div class="robot-container">
        <div class="robot-header">
            <div class="robot-title">
                <img src="icon.ico" alt="Logo" style="width: 40px; height: 40px;">
                <h1>Control Avanzado del Robot</h1>
            </div>
        </div>

        <!-- Estado de Conexi√≥n -->
        <div class="robot-section">
            <h2>Estado del Sistema</h2>
            <div class="status-grid">
                <div class="status-card">
                    <div>
                        <span class="status-indicator" id="rosStatus"></span>
                        <strong>ROS Bridge</strong>
                    </div>
                    <div id="rosStatusText">Desconectado</div>
                </div>
                <div class="status-card">
                    <div>
                        <span class="status-indicator" id="robotStatus"></span>
                        <strong>Robot TurtleBot</strong>
                    </div>
                    <div id="robotStatusText">Desconectado</div>
                </div>
                <div class="status-card">
                    <div><strong>√öltimo Mensaje</strong></div>
                    <div id="lastMessage">-</div>
                </div>
            </div>
        </div>

        <!-- Panel de Control -->
        <div class="control-panel">
            <!-- Controles de Movimiento -->
            <div class="movement-controls">
                <h3>Control de Movimiento</h3>
                <div class="movement-grid">
                    <div></div>
                    <button class="movement-btn" id="moveForward">‚¨Ü</button>
                    <div></div>
                    <button class="movement-btn" id="turnLeft">‚¨Ö</button>
                    <button class="movement-btn" id="stopRobot">STOP</button>
                    <button class="movement-btn" id="turnRight">‚û°</button>
                    <div></div>
                    <button class="movement-btn" id="moveBackward">‚¨á</button>
                    <div></div>
                </div>
                
                <div class="velocity-display">
                    <div class="velocity-item">
                        <div>Vel. Linear</div>
                        <div class="velocity-value" id="linearVel">0.0</div>
                    </div>
                    <div class="velocity-item">
                        <div>Vel. Angular</div>
                        <div class="velocity-value" id="angularVel">0.0</div>
                    </div>
                    <div class="velocity-item">
                        <div>Velocidad</div>
                        <div class="velocity-value" id="speedLevel">0</div>
                    </div>
                </div>
            </div>

            <!-- Datos de Sensores -->
            <div class="sensor-data">
                <h3>Datos de Sensores</h3>
                <div>
                    <strong>Posici√≥n (Odometr√≠a):</strong>
                    <div id="positionData">
                        X: -, Y: -, Z: -<br>
                        Orientaci√≥n: -
                    </div>
                </div>
                <div style="margin-top: 15px;">
                    <strong>Sensor LIDAR:</strong>
                    <div id="laserData">
                        Distancia m√≠n: -, Distancia m√°x: -<br>
                        Obst√°culos detectados: -
                    </div>
                </div>
                <div style="margin-top: 15px;">
                    <strong>Estado de la Bater√≠a:</strong>
                    <div id="batteryData">Nivel: -, Voltaje: -, Estado: -</div>
                </div>
            </div>
        </div>

        <!-- C√°mara del Robot -->
        <div class="camera-section">
            <h2>C√°mara del Robot</h2>
            <div class="camera-container">
                <img id="cameraStream" class="camera-stream" 
                     src="http://turtlebot-nuc.local:8080/stream?topic=/camera/color/image_raw" 
                     alt="Transmisi√≥n de la c√°mara del robot">
                <div class="camera-status">
                    <div class="camera-indicator" id="cameraIndicator"></div>
                    <span id="cameraStatusText">Conectando...</span>
                </div>
                <div class="camera-error" id="cameraError">
                    ‚ùå No se pudo conectar a la transmisi√≥n de la c√°mara<br>
                    Verifica que el robot est√© encendido y conectado
                </div>
            </div>
        </div>

        <!-- Sistema de S√≠ntesis de Voz -->
        <div class="robot-section">
            <h2>Voz del Robot</h2>
            <div class="speech-container">
                <div class="speech-controls">
                    <div class="speech-input-group">
                        <label for="speechText" class="speech-label">Texto para que el robot diga:</label>
                        <textarea id="speechText" 
                                  class="speech-textarea" 
                                  placeholder="Escribe aqu√≠ lo que quieres que diga el robot... (m√°ximo 500 caracteres)"
                                  maxlength="500" 
                                  rows="4"></textarea>
                        <div class="speech-counter">
                            <span id="charCount">0</span>/500 caracteres
                        </div>
                    </div>
                    
                    <div class="speech-buttons">
                        <button id="speakBtn" class="btn btn-primary speech-btn" onclick="speakText()">
                            üîä Hablar
                        </button>
                    </div>
                    
                    <div class="speech-presets">
                        <label class="speech-label">Frases predefinidas para tours:</label>
                        <div class="preset-buttons">
                            <button class="preset-btn" onclick="setSpeechText('Hola, soy artTEC, su robot gu√≠a del museo.')"> Saludo</button>
                            <button class="preset-btn" onclick="setSpeechText('S√≠ganme, por favor.')"> Seguir</button>
                            <button class="preset-btn" onclick="setSpeechText('Cuidado, robot en movimiento.')"> Cuidado</button>
                            <button class="preset-btn" onclick="setSpeechText('Por favor, mant√©nganse cerca del robot durante el recorrido.')"> Instrucci√≥n</button>
                            <button class="preset-btn" onclick="setSpeechText('Atenci√≥n, se detect√≥ un impacto. Por favor eviten el √°rea.')"> Colision</button>
                            <button class="preset-btn" onclick="setSpeechText('Gracias por acompa√±arme en este recorrido. ¬°Hasta luego!')"> Despedida</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Log del Sistema -->
        <div class="robot-section">
            <h2>Log del Sistema</h2>
            <div class="log-area" id="systemLog">
                Sistema iniciado...<br>
            </div>
            <button onclick="clearLog()" class="btn btn-secondary" style="margin-top: 10px;">Limpiar Log</button>
        </div>

        <!-- Topicos ROS Disponibles -->
        <div class="robot-section">
            <h2>T√≥picos ROS Disponibles</h2>
            <div style="margin-bottom: 15px;">
                <button onclick="getTopicList()" class="btn btn-secondary">Actualizar T√≥picos</button>
                <span style="margin-left: 15px; color: #666;">
                    Total: <span id="topicCount">0</span> t√≥picos
                </span>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h4>T√≥picos de Publicaci√≥n (Comandos)</h4>
                    <div class="topic-list" id="publishTopics">
                        Cargando t√≥picos...
                    </div>
                </div>
                <div>
                    <h4>T√≥picos de Suscripci√≥n (Sensores)</h4>
                    <div class="topic-list" id="subscribeTopics">
                        Cargando t√≥picos...
                    </div>
                </div>
            </div>
        </div>

        <!-- Panel de Navegaci√≥n por Zonas -->
        <div class="robot-section">
            <h2>üó∫Ô∏è Navegaci√≥n por Zonas</h2>
            <div class="zone-navigation-container">
                <div class="zone-nav-controls">
                    <div class="zone-selector-group">
                        <label for="zoneSelect">Seleccionar Zona:</label>
                        <select id="zoneSelect" class="zone-select">
                            <option value="">Cargando zonas...</option>
                        </select>
                        <button id="refreshZonesBtn" class="btn btn-secondary" onclick="loadAvailableZones()">
                            üîÑ Actualizar
                        </button>
                    </div>
                    
                    <div class="zone-nav-actions">
                        <button id="goToZoneBtn" class="btn btn-primary" onclick="navigateToZone()" disabled>
                            üéØ Ir a Zona
                        </button>
                        <div class="zone-nav-status">
                            <span id="navStatusText">Sistema listo</span>
                            <div class="nav-status-indicator" id="navStatusIndicator"></div>
                        </div>
                    </div>
                </div>
                
                <div id="selectedZoneInfo" class="zone-info-panel" style="display: none;">
                    <h4>Informaci√≥n de la Zona</h4>
                    <div class="zone-info-details">
                        <p><strong>Nombre:</strong> <span id="zoneInfoName"></span></p>
                        <p><strong>Tipo:</strong> <span id="zoneInfoType"></span></p>
                        <p><strong>Centro:</strong> <span id="zoneInfoCenter"></span></p>
                        <p><strong>Estado:</strong> <span id="navigationStatus">Listo para navegar</span></p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mapa y Navegaci√≥n por Waypoints 3D -->
        <div class="robot-section">
            <h2>Navegaci√≥n por Waypoints 3D</h2>
            <div class="waypoints-3d-container">
                <div class="waypoints-controls">
                    <button id="setInitialPose3D" style="background: #17a2b8; color: white;">üìç Establecer Posici√≥n Inicial</button>
                    <button id="startRoute3D">Iniciar Ruta</button>
                    <button id="nextWaypoint3D" style="display:none;">Siguiente Objetivo</button>
                    <button id="clearWaypoints3D">Limpiar Waypoints</button>
                    <button id="openZonesModal" onclick="openZonesModal()" style="background: #28a745; color: white;">üó∫Ô∏è Crear Zonas</button>
                    <span>Waypoints: <span id="waypointCount3D">0</span></span>
                    <div class="waypoints-status" id="routeStatus3D"></div>
                    <div class="waypoints-status" id="initialPoseStatus3D"></div>
                </div>
                <div id="map3D" style="width:100%; height:600px; position: relative;">
                    <div class="map-3d-info">
                        <strong>Mapa 3D Waypoints & Localizaci√≥n</strong><br>
                        Robot: <span id="robotPos3D">Desconocido</span><br>
                        Mapa: <span id="mapStatus3D">Inicializando...</span><br>
                        Waypoints: <span id="waypointDisplay3D">0</span><br>
                        <small>Clic para waypoints | Bot√≥n azul para posici√≥n inicial</small><br>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de Creaci√≥n de Zonas -->
    <div id="zonesModal" class="zones-modal">
        <div class="zones-modal-content">
            <div class="zones-modal-header">
                <h2>üó∫Ô∏è Creaci√≥n de Zonas</h2>
                <button class="zones-close" onclick="closeZonesModal()">&times;</button>
            </div>
            
            <div class="zones-content">
                <!-- Contenedor del mapa -->
                <div class="zones-map-container">
                    <canvas id="zonesCanvas" class="zones-map"></canvas>
                </div>
                
                <!-- Panel de controles -->
                <div class="zones-controls">
                    <div class="zone-instructions">
                        üìå <strong>Instrucciones:</strong><br>
                        1. Haz clic en 4 puntos para definir una zona (cuadril√°tero)<br>
                        2. Los puntos se conectar√°n autom√°ticamente en orden<br>
                        3. Asigna un nombre y color, luego guarda la zona
                    </div>
                    
                    <div id="zoneStatus" class="zone-status zone-status-info" style="display: none;">
                        Listo para crear zonas
                    </div>
                    
                    <div class="zone-form">
                        <h3>Nueva Zona</h3>
                        
                        <div class="zone-input-group">
                            <label for="zoneName">Nombre de la Zona:</label>
                            <input type="text" id="zoneName" placeholder="Ej: Sala de escultura" maxlength="50">
                        </div>
                        
                        <div class="zone-input-group">
                            <label for="zoneColor">Color de la Zona:</label>
                            <select id="zoneColor" onchange="updateColorPreview()">
                                <option value="#ff4444"> Rojo</option>
                                <option value="#44ff44"> Verde</option>
                                <option value="#4444ff"> Azul</option>
                                <option value="#ffff44"> Amarillo</option>
                                <option value="#ff44ff"> Magenta</option>
                                <option value="#44ffff"> Cian</option>
                                <option value="#ff8844"> Naranja</option>
                                <option value="#8844ff"> P√∫rpura</option>
                            </select>
                            <div id="zoneColorPreview" class="zone-color-preview" style="background-color: #ff4444;"></div>
                        </div>
                        
                        <div class="zone-buttons">
                            <button id="clearZoneBtn" class="zone-btn zone-btn-secondary" onclick="clearCurrentZone()" disabled>
                                üóëÔ∏è Limpiar
                            </button>
                            <button id="saveZoneBtn" class="zone-btn zone-btn-primary" onclick="saveCurrentZone()" disabled>
                                üíæ Guardar
                            </button>
                        </div>
                    </div>
                    
                    <div class="zones-list-container">
                        <h3>Zonas Guardadas</h3>
                        <div id="savedZonesList" class="zones-list">
                            <!-- Las zonas guardadas aparecer√°n aqu√≠ -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables globales para ROS
        let ros = null;
        let cmdVelTopic = null;
        let odomTopic = null;
        let laserTopic = null;
        let diagnosticTopic = null;
        let mapTopic = null;
        let currentUser = null;
        
        // Variables de la c√°mara
        let cameraStream = null;
        let cameraConnected = false;
        let cameraRetryCount = 0;
        let maxCameraRetries = 5;
        
        // Variables del sistema de waypoints 3D
        let scene3D, camera3D, renderer3D;
        let waypoints3D = [];
        let robotMarker3D = null;
        let waypointMarkers3D = [];
        let mapPlane3D = null;
        let currentMapData3D = null;
        let currentWaypointIndex3D = 0;
        let routeActive3D = false;
        let goalTopic3D = null;
        let initialPoseTopic3D = null;
        let isSettingInitialPose = false;
        let initialPoseStep = 0; // 0: esperando posici√≥n, 1: esperando direcci√≥n
        
        // Configuraci√≥n del mapa 3D
        let mapConfig3D = {
            width: 20,
            height: 20,
            resolution: 0.05,
            originX: -10,
            originY: -10
        };
        
        // Estado del robot
        let robotState = {
            connected: false,
            position: { x: 0, y: 0, z: 0, orientation: 0 },
            velocity: { linear: 0, angular: 0 },
            laser: { min: 0, max: 0, obstacles: 0 },
            battery: { 
                level: 0, 
                voltage: 0, 
                status: 'Unknown',
                charge: 0,
                capacity: 0,
                source: 'Unknown',
                chargingState: 'Unknown',
                current: 0
            }
        };

        // Variables del sistema de zonas
        let zonesCanvas = null;
        let zonesContext = null;
        let zonesModal = null;
        let isDrawingZone = false;
        let currentZone = null;
        let savedZones = [];
        let zonePoints = []; // Array para almacenar los 4 puntos de la zona
        let currentPointIndex = 0; // √çndice del punto actual (0-3)
        let mousePosition = { x: 0, y: 0 };
        
        // Variables del mapa para zonas
        let zonesMapTopic = null;
        let zonesMapData = null;
        let zonesMapConfig = {
            width: 20,
            height: 20,
            resolution: 0.05,
            originX: -10,
            originY: -10
        };

        // Configurar eventos de DOM al cargar la p√°gina
        document.addEventListener('DOMContentLoaded', function() {
            setupMobileNavigation();
            setupUserDropdown();
        });

        // Inicializar cuando se carga la p√°gina
        window.addEventListener('load', async () => {
            await checkUserAccess();
            initializeROS();
            initializeCamera();
            setTimeout(() => {
                initialize3DWaypoints();
                initZoneNavigation(); // Inicializar navegaci√≥n a zonas
            }, 1000);
        });

        // Verificar que Three.js est√° disponible
        function checkThreeJS() {
            if (typeof THREE === 'undefined') {
                addLog('ERROR: Three.js no se ha cargado correctamente');
                return false;
            }
            addLog('Three.js cargado correctamente, versi√≥n: ' + THREE.REVISION);
            return true;
        }

        // Configurar navegaci√≥n m√≥vil
        function setupMobileNavigation() {
            const navToggle = document.getElementById('navToggle');
            const navMenu = document.querySelector('.nav-menu');
            
            if (navToggle && navMenu) {
                navToggle.addEventListener('click', () => {
                    navMenu.classList.toggle('nav-menu-active');
                    navToggle.classList.toggle('toggle-active');
                });

                // Cerrar men√∫ m√≥vil al hacer clic en un enlace
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.addEventListener('click', () => {
                        navMenu.classList.remove('nav-menu-active');
                        navToggle.classList.remove('toggle-active');
                    });
                });

                // Configurar logout desde navegaci√≥n m√≥vil
                const navMobileLogoutBtn = document.getElementById('navMobileLogoutBtn');
                if (navMobileLogoutBtn) {
                    navMobileLogoutBtn.addEventListener('click', logoutUser);
                }
            }
        }

        // Configurar dropdown de usuario en navegaci√≥n
        function setupUserDropdown() {
            const navUserToggle = document.getElementById('navUserToggle');
            const navDropdownMenu = document.getElementById('navDropdownMenu');

            if (navUserToggle && navDropdownMenu) {
                navUserToggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    navDropdownMenu.classList.toggle('nav-dropdown-open');
                });

                // Cerrar dropdown al hacer clic fuera
                document.addEventListener('click', (event) => {
                    if (!navUserToggle.contains(event.target) && !navDropdownMenu.contains(event.target)) {
                        navDropdownMenu.classList.remove('nav-dropdown-open');
                    }
                });

                // Prevenir que el dropdown se cierre al hacer clic dentro
                navDropdownMenu.addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                // Configurar logout desde navegaci√≥n
                const navLogoutBtn = document.getElementById('navLogoutBtn');
                if (navLogoutBtn) {
                    navLogoutBtn.addEventListener('click', logoutUser);
                }
            }
        }

        // Mostrar estado de usuario logueado
        function updateUIForLoggedInUser(userData) {
            // Actualizar nombre en navegaci√≥n
            const navUsername = document.getElementById('navUsername');
            const navMobileUsername = document.getElementById('nav-mobile-username');
            if (navUsername) navUsername.textContent = userData.username;
            if (navMobileUsername) navMobileUsername.textContent = userData.username;

            // Actualizar foto de perfil en navegaci√≥n
            const navUserAvatar = document.getElementById('navUserAvatar');
            if (navUserAvatar) {
                navUserAvatar.src = userData.profile_picture || '/favicon.ico';
                navUserAvatar.alt = `Foto de ${userData.username}`;
            }

            // Mostrar men√∫ de usuario y ocultar botones de auth
            const navUserMenu = document.getElementById('navUserMenu');
            const navAuthMenu = document.getElementById('navAuthMenu');
            const navMobileUser = document.querySelectorAll('.nav-mobile-user');
            const navMobileAuth = document.getElementById('navMobileAuth');

            if (navUserMenu) navUserMenu.style.display = 'flex';
            if (navAuthMenu) navAuthMenu.style.display = 'none';
            if (navMobileAuth) navMobileAuth.style.display = 'none';
            
            navMobileUser.forEach(element => {
                if (element) element.style.display = 'block';
            });

            // Control de visibilidad de botones seg√∫n el rol del usuario
            const navAdmin = document.getElementById('navAdmin');
            const navStats = document.getElementById('navStats');
            const navNotifications = document.getElementById('navNotifications');
            const navRobotControl = document.getElementById('navRobotControl');
            
            if (userData.role === 'admin') {
                // Admin: todos los botones visibles
                if (navRobotControl) {
                    navRobotControl.style.display = 'block';
                    navRobotControl.parentElement.style.display = 'block';
                }
                if (navAdmin) {
                    navAdmin.style.display = 'block';
                    navAdmin.parentElement.style.display = 'block';
                }
                if (navStats) {
                    navStats.style.display = 'block';
                    navStats.parentElement.style.display = 'block';
                }
                if (navNotifications) {
                    navNotifications.style.display = 'block';
                    navNotifications.parentElement.style.display = 'block';
                }
                addLog('Acceso de administrador: Todos los botones disponibles');
            } else if (userData.role === 'tecnico') {
                // T√©cnico: Inicio, Tours, C√≥mo Funciona, Control Robot
                if (navRobotControl) {
                    navRobotControl.style.display = 'block';
                    navRobotControl.parentElement.style.display = 'block';
                }
                if (navAdmin) {
                    navAdmin.style.display = 'none';
                    navAdmin.parentElement.style.display = 'none';
                }
                if (navStats) {
                    navStats.style.display = 'none';
                    navStats.parentElement.style.display = 'none';
                }
                if (navNotifications) {
                    navNotifications.style.display = 'none';
                    navNotifications.parentElement.style.display = 'none';
                }
                addLog('Acceso de t√©cnico: Control Robot disponible, botones admin ocultos');
            } else {
                // Usuario normal: solo Inicio, Tours, C√≥mo Funciona
                if (navRobotControl) {
                    navRobotControl.style.display = 'none';
                    navRobotControl.parentElement.style.display = 'none';
                }
                if (navAdmin) {
                    navAdmin.style.display = 'none';
                    navAdmin.parentElement.style.display = 'none';
                }
                if (navStats) {
                    navStats.style.display = 'none';
                    navStats.parentElement.style.display = 'none';
                }
                if (navNotifications) {
                    navNotifications.style.display = 'none';
                    navNotifications.parentElement.style.display = 'none';
                }
                addLog('Acceso de usuario normal: Solo men√∫ b√°sico disponible');
            }
        }

        // Funci√≥n unificada de logout
        async function logoutUser() {
            try {
                const response = await fetch('/api/logout', { method: 'POST' });
                if (response.ok) {
                    window.location.href = '/';
                }
            } catch (error) {
                console.error('Error al cerrar sesi√≥n:', error);
            }
        }

        // Mostrar mensajes al usuario
        function showMessage(message, type = 'info') {
            // Crear elemento de mensaje si no existe
            let messageDiv = document.getElementById('messageDiv');
            if (!messageDiv) {
                messageDiv = document.createElement('div');
                messageDiv.id = 'messageDiv';
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 80px;
                    right: 20px;
                    padding: 12px 20px;
                    border-radius: 4px;
                    color: white;
                    font-weight: 500;
                    z-index: 10000;
                    max-width: 400px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                `;
                document.body.appendChild(messageDiv);
            }

            // Colores seg√∫n el tipo
            const colors = {
                success: '#28a745',
                error: '#dc3545',
                warning: '#ffc107',
                info: '#17a2b8'
            };

            messageDiv.style.backgroundColor = colors[type] || colors.info;
            messageDiv.textContent = message;
            messageDiv.style.display = 'block';

            // Ocultar despu√©s de 3 segundos
            setTimeout(() => {
                messageDiv.style.display = 'none';
            }, 3000);
        }

        // Verificar acceso del usuario
        async function checkUserAccess() {
            try {
                const response = await fetch('/api/user');
                if (response.ok) {
                    const userData = await response.json();
                    currentUser = userData;
                    updateUIForLoggedInUser(userData);
                } else {
                    window.location.href = '/login';
                }
            } catch (error) {
                window.location.href = '/login';
            }
        }

        // ===== SISTEMA DE C√ÅMARA =====

        // Inicializar c√°mara
        function initializeCamera() {
            addLog('Inicializando transmisi√≥n de c√°mara...');
            
            cameraStream = document.getElementById('cameraStream');
            
            // Configurar eventos de la imagen
            cameraStream.onload = function() {
                cameraConnected = true;
                cameraRetryCount = 0;
                updateCameraStatus(true, 'Conectada');
            };
            
            cameraStream.onerror = function() {
                cameraConnected = false;
                updateCameraStatus(false, 'Error de conexi√≥n');
                addLog('Error al conectar con la c√°mara');
                
                // Mostrar mensaje de error
                document.getElementById('cameraError').style.display = 'block';
                cameraStream.style.display = 'none';
                
                // Reintentar conexi√≥n
                if (cameraRetryCount < maxCameraRetries) {
                    cameraRetryCount++;
                    addLog(`Reintentando conexi√≥n de c√°mara (${cameraRetryCount}/${maxCameraRetries})...`);
                    setTimeout(() => {
                        reloadCamera();
                    }, 3000);
                }
            };
            
            // Verificar estado de la c√°mara peri√≥dicamente
            setInterval(checkCameraStatus, 10000); // Cada 10 segundos
        }

        // Actualizar estado visual de la c√°mara
        function updateCameraStatus(connected, statusText) {
            const indicator = document.getElementById('cameraIndicator');
            const statusElement = document.getElementById('cameraStatusText');
            
            if (connected) {
                indicator.classList.remove('disconnected');
                indicator.style.background = '#28a745';
            } else {
                indicator.classList.add('disconnected');
                indicator.style.background = '#dc3545';
            }
            
            statusElement.textContent = statusText;
        }

        // Verificar estado de la c√°mara
        function checkCameraStatus() {
            if (!cameraConnected && cameraRetryCount >= maxCameraRetries) {
                updateCameraStatus(false, 'Sin conexi√≥n');
            }
        }
        // Inicializar conexi√≥n ROS
        function initializeROS() {
            addLog('Conectando a ROS Bridge...');
            
            // Crear conexi√≥n ROS
            ros = new ROSLIB.Ros({
                url: 'ws://turtlebot-NUC.local:9090'
            });

            // Eventos de conexi√≥n
            ros.on('connection', function() {
                addLog('Conectado a ROS Bridge');
                updateConnectionStatus(true);
                setupTopics();
                getTopicList();
            });

            ros.on('error', function(error) {
                addLog('Error de ROS: ' + error);
                updateConnectionStatus(false);
            });

            ros.on('close', function() {
                addLog('Conexion ROS cerrada');
                updateConnectionStatus(false);
            });
        }

        // Configurar t√≥picos ROS
        function setupTopics() {
            // T√≥pico para enviar comandos de velocidad (TurtleBot espec√≠fico)
            cmdVelTopic = new ROSLIB.Topic({
                ros: ros,
                name: '/mobile_base/commands/velocity',
                messageType: 'geometry_msgs/Twist'
            });

            // T√≥pico para recibir odometr√≠a
            odomTopic = new ROSLIB.Topic({
                ros: ros,
                name: '/odom',
                messageType: 'nav_msgs/Odometry'
            });

            odomTopic.subscribe(function(message) {
                updateOdometry(message);
            });

            // T√≥pico para datos del l√°ser - probar m√∫ltiples t√≥picos
            laserTopic = new ROSLIB.Topic({
                ros: ros,
                name: '/scan',  // TurtleBot normalmente usa /scan
                messageType: 'sensor_msgs/LaserScan'
            });

            laserTopic.subscribe(function(message) {
                updateLaserData(message);
            });
            
            // Fallback: tambi√©n suscribirse a /laser si existe
            const laserTopicAlt = new ROSLIB.Topic({
                ros: ros,
                name: '/laser',
                messageType: 'sensor_msgs/LaserScan'
            });

            laserTopicAlt.subscribe(function(message) {
                updateLaserData(message);
            });

            // T√≥pico para diagn√≥sticos (incluyendo bater√≠a)
            diagnosticTopic = new ROSLIB.Topic({
                ros: ros,
                name: '/diagnostics',
                messageType: 'diagnostic_msgs/DiagnosticArray'
            });

            diagnosticTopic.subscribe(function(message) {
                updateDiagnostics(message);
            });

            // T√≥pico para enviar objetivos de navegaci√≥n (waypoints)
            goalTopic3D = new ROSLIB.Topic({
                ros: ros,
                name: '/move_base_simple/goal',
                messageType: 'geometry_msgs/PoseStamped'
            });

            // T√≥pico para establecer posici√≥n inicial del robot
            initialPoseTopic3D = new ROSLIB.Topic({
                ros: ros,
                name: '/initialpose',
                messageType: 'geometry_msgs/PoseWithCovarianceStamped'
            });

            addLog('Topicos TurtleBot configurados correctamente');
            
            // Iniciar monitoreo de t√≥picos
            startTopicMonitoring();
        }
        
        // Variables para monitoreo de t√≥picos
        let lastOdomTime = 0;
        let lastLaserTime = 0;
        let lastDiagnosticsTime = 0;
        
        // Monitorear actividad de t√≥picos
        function startTopicMonitoring() {
            setInterval(() => {
                const now = Date.now();
                const timeout = 5000; // 5 segundos sin datos
                
                // Verificar si los t√≥picos est√°n enviando datos
                if (now - lastOdomTime > timeout && lastOdomTime > 0) {
                    addLog('Topico /odom sin datos por mas de 5 segundos');
                }
                
                if (now - lastLaserTime > timeout && lastLaserTime > 0) {
                    addLog('Topico /laser sin datos por mas de 5 segundos');
                }
                
                if (now - lastDiagnosticsTime > timeout && lastDiagnosticsTime > 0) {
                    addLog('Topico /diagnostics sin datos por mas de 5 segundos');
                }
            }, 10000); // Verificar cada 10 segundos
        }

        // Obtener lista de t√≥picos disponibles
        function getTopicList() {
            // Primero intentar obtener desde ROS directamente
            if (ros && ros.getTopics) {
                ros.getTopics(function(result) {
                    // Verificar si result es un array o tiene propiedad topics
                    let topics = [];
                    if (Array.isArray(result)) {
                        topics = result;
                    } else if (result && Array.isArray(result.topics)) {
                        topics = result.topics;
                    } else {
                        addLog(`Formato de topicos inesperado desde ROS`);
                        getTopicsFromAPI();
                        return;
                    }
                    
                    displayTopics(topics);
                    addLog(`${topics.length} topicos encontrados directamente desde ROS`);
                }, function(error) {
                    addLog(`Error obteniendo topicos desde ROS: ${error}`);
                    // Fallback: obtener desde API del servidor
                    getTopicsFromAPI();
                });
            } else {
                getTopicsFromAPI();
            }
        }

        // Obtener t√≥picos desde la API del servidor
        async function getTopicsFromAPI() {
            try {
                const response = await fetch('/api/robot/topics');
                if (response.ok) {
                    const data = await response.json();
                    displayTopics(data.topics);
                    addLog(`${data.topic_count} topicos obtenidos desde API`);
                } else {
                    addLog('Error obteniendo topicos desde API');
                }
            } catch (error) {
                addLog(`Error de conexion al obtener topicos: ${error.message}`);
            }
        }

        // Mostrar t√≥picos en la interfaz
        function displayTopics(topics) {
            // Verificar que topics es un array
            if (!Array.isArray(topics)) {
                addLog(`Error: topics no es un array: ${typeof topics}`);
                return;
            }
            
            const publishDiv = document.getElementById('publishTopics');
            const subscribeDiv = document.getElementById('subscribeTopics');
            
            // T√≥picos de publicaci√≥n (comandos que podemos enviar)
            const publishTopics = topics.filter(topic => 
                topic.includes('/mobile_base/commands/') || 
                topic.includes('/cmd_vel') || 
                topic.includes('/move_base_simple/goal') ||
                topic.includes('/initialpose')
            );
            
            // T√≥picos de suscripci√≥n (datos que recibimos)
            const sensorTopics = topics.filter(topic => 
                topic.includes('/odom') || 
                topic.includes('/laser') || 
                topic.includes('/diagnostics') ||
                topic.includes('/imu') || 
                topic.includes('/battery') ||
                topic.includes('/mobile_base/sensors/')
            );

            publishDiv.innerHTML = publishTopics.length > 0 ? 
                publishTopics.map(topic => `<div class="topic-item">${topic}</div>`).join('') :
                '<div class="topic-item">No hay t√≥picos de publicaci√≥n disponibles</div>';

            subscribeDiv.innerHTML = sensorTopics.length > 0 ? 
                sensorTopics.map(topic => `<div class="topic-item">${topic}</div>`).join('') :
                '<div class="topic-item">No hay t√≥picos de sensores disponibles</div>';
                
        }

        // Actualizar estado de conexi√≥n
        function updateConnectionStatus(connected) {
            const rosStatus = document.getElementById('rosStatus');
            const rosStatusText = document.getElementById('rosStatusText');
            const robotStatus = document.getElementById('robotStatus');
            const robotStatusText = document.getElementById('robotStatusText');
            
            if (connected) {
                rosStatus.className = 'status-indicator status-connected';
                rosStatusText.textContent = 'Conectado';
                robotStatus.className = 'status-indicator status-connected';
                robotStatusText.textContent = 'Operativo';
                enableMovementControls(true);
            } else {
                rosStatus.className = 'status-indicator status-disconnected';
                rosStatusText.textContent = 'Desconectado';
                robotStatus.className = 'status-indicator status-disconnected';
                robotStatusText.textContent = 'No disponible';
                enableMovementControls(false);
            }
            
            robotState.connected = connected;
        }

        // Habilitar/deshabilitar controles de movimiento
        function enableMovementControls(enabled) {
            const buttons = document.querySelectorAll('.movement-btn');
            buttons.forEach(btn => btn.disabled = !enabled);
        }

        // Actualizar datos de odometr√≠a
        function updateOdometry(message) {
            try {
                lastOdomTime = Date.now(); // Registrar actividad
                
                if (!message || !message.pose || !message.pose.pose) {
                    addLog('Datos de odometria invalidos recibidos');
                    return;
                }
                
                robotState.position.x = message.pose.pose.position.x.toFixed(2);
                robotState.position.y = message.pose.pose.position.y.toFixed(2);
                robotState.position.z = message.pose.pose.position.z.toFixed(2);
                
                // Calcular orientaci√≥n desde quaternion
                const q = message.pose.pose.orientation;
                const yaw = Math.atan2(2.0 * (q.w * q.z + q.x * q.y), 1.0 - 2.0 * (q.y * q.y + q.z * q.z));
                robotState.position.orientation = (yaw * 180 / Math.PI).toFixed(1);

                // Actualizar velocidades
                if (message.twist && message.twist.twist) {
                    robotState.velocity.linear = message.twist.twist.linear.x.toFixed(2);
                    robotState.velocity.angular = message.twist.twist.angular.z.toFixed(2);
                }

                updatePositionDisplay();
                document.getElementById('lastMessage').textContent = new Date().toLocaleTimeString();
            } catch (error) {
                addLog(`Error procesando odometria: ${error.message}`);
            }
        }

        // Actualizar datos del l√°ser
        function updateLaserData(message) {
            try {
                lastLaserTime = Date.now(); // Registrar actividad
                
                if (!message || !message.ranges || !Array.isArray(message.ranges)) {
                    addLog('Datos de laser invalidos recibidos');
                    return;
                }
                
                const ranges = message.ranges;
                const rangeMin = message.range_min || 0.12;
                const rangeMax = message.range_max || 3.5;
                
                // Filtrar rangos v√°lidos y no infinitos
                const validRanges = ranges.filter(r => 
                    !isNaN(r) && 
                    isFinite(r) && 
                    r > rangeMin && 
                    r < rangeMax
                );
                
                if (validRanges.length === 0) {
                    robotState.laser.min = 0;
                    robotState.laser.max = 0;
                    robotState.laser.obstacles = 0;
                    // Log menos frecuente
                    if (Math.random() < 0.05) {
                        addLog('No hay datos validos de laser');
                    }
                } else {
                    robotState.laser.min = Math.min(...validRanges).toFixed(2);
                    robotState.laser.max = Math.max(...validRanges).toFixed(2);
                    robotState.laser.obstacles = validRanges.filter(r => r < 1.0).length;
                }

                updateLaserDisplay();
                document.getElementById('lastMessage').textContent = new Date().toLocaleTimeString();
            } catch (error) {
                addLog(`Error procesando datos de laser: ${error.message}`);
            }
        }

        // Actualizar visualizaci√≥n de posici√≥n
        function updatePositionDisplay() {
            document.getElementById('positionData').innerHTML = 
                `X: ${robotState.position.x}m, Y: ${robotState.position.y}m, Z: ${robotState.position.z}m<br>` +
                `Orientaci√≥n: ${robotState.position.orientation}¬∞`;
            
            document.getElementById('linearVel').textContent = robotState.velocity.linear;
            document.getElementById('angularVel').textContent = robotState.velocity.angular;
        }

        // Actualizar visualizaci√≥n del l√°ser
        function updateLaserDisplay() {
            document.getElementById('laserData').innerHTML = 
                `Distancia m√≠n: ${robotState.laser.min}m, Distancia m√°x: ${robotState.laser.max}m<br>` +
                `Obst√°culos detectados: ${robotState.laser.obstacles}`;
        }

        // Actualizar datos de diagn√≥sticos (incluyendo bater√≠a)
        function updateDiagnostics(message) {
            try {
                lastDiagnosticsTime = Date.now(); // Registrar actividad
                
                if (!message || !message.status || !Array.isArray(message.status)) {
                    addLog('Mensaje de diagnosticos invalido recibido');
                    return;
                }
                
                if (message.status.length === 0) {
                    addLog('No hay estados de diagnostico en el mensaje');
                    return;
                }
                
                let batteryFound = false;
                
                message.status.forEach((status, index) => {
                    // Buscar informaci√≥n de bater√≠a espec√≠fica del TurtleBot (Kobuki)
                    if (status.name && status.name.includes('Battery') && status.hardware_id === 'Kobuki') {
                        batteryFound = true;
                        
                        // Obtener el mensaje de estado general
                        robotState.battery.status = status.message || 'Unknown';
                        
                        // Procesar valores espec√≠ficos
                        if (status.values && Array.isArray(status.values) && status.values.length > 0) {
                            status.values.forEach(value => {
                                if (!value.key || !value.value) return;
                                
                                switch(value.key) {
                                    case 'Voltage (V)':
                                        robotState.battery.voltage = parseFloat(value.value).toFixed(2);
                                        break;
                                    case 'Percent':
                                        robotState.battery.level = parseFloat(value.value).toFixed(1);
                                        break;
                                    case 'Charge (Ah)':
                                        robotState.battery.charge = parseFloat(value.value).toFixed(2);
                                        break;
                                    case 'Capacity (Ah)':
                                        robotState.battery.capacity = parseFloat(value.value).toFixed(2);
                                        break;
                                    case 'Source':
                                        robotState.battery.source = value.value;
                                        break;
                                    case 'Charging State':
                                        robotState.battery.chargingState = value.value;
                                        break;
                                    case 'Current (A)':
                                        robotState.battery.current = parseFloat(value.value).toFixed(2);
                                        break;
                                }
                            });
                        }
                        
                        updateBatteryDisplay();
                        
                        // Log menos frecuente para la bater√≠a
                        if (Math.random() < 0.1) { // Solo 10% de las veces
                            addLog(`Bateria Kobuki: ${robotState.battery.level}% - ${robotState.battery.status} (${robotState.battery.voltage}V)`);
                        }
                    }
                });
                
                if (!batteryFound) {
                    // Log ocasional cuando no se encuentra bater√≠a
                    if (Math.random() < 0.05) { // Solo 5% de las veces
                        addLog(`No se encontro informacion de bateria Kobuki en ${message.status.length} estados`);
                    }
                }
                
                document.getElementById('lastMessage').textContent = new Date().toLocaleTimeString();
                
            } catch (error) {
                addLog(`Error procesando diagnosticos: ${error.message}`);
            }
        }

        // Actualizar visualizaci√≥n de la bater√≠a
        function updateBatteryDisplay() {
            const batteryLevel = robotState.battery.level || 'N/A';
            const batteryVoltage = robotState.battery.voltage || 'N/A';
            const batteryStatus = robotState.battery.status || 'Unknown';
            const chargingState = robotState.battery.chargingState || 'Unknown';
            const source = robotState.battery.source || 'Unknown';
            const current = robotState.battery.current || 'N/A';
            
            // Determinar color del nivel de bater√≠a
            let levelColor = '#28a745'; // Verde
            if (batteryLevel < 30) {
                levelColor = '#dc3545'; // Rojo
            } else if (batteryLevel < 50) {
                levelColor = '#ffc107'; // Amarillo
            }
            
            document.getElementById('batteryData').innerHTML = 
                `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">` +
                    `<div><strong>Nivel:</strong> <span style="color: ${levelColor}; font-weight: bold;">${batteryLevel}%</span></div>` +
                    `<div><strong>Voltaje:</strong> ${batteryVoltage}V</div>` +
                    `<div><strong>Estado:</strong> ${batteryStatus}</div>` +
                    `<div><strong>Fuente:</strong> ${source}</div>` +
                    `<div><strong>Carga:</strong> ${chargingState}</div>` +
                    `<div><strong>Corriente:</strong> ${current}A</div>` +
                `</div>`;
        }

        // Enviar comando de velocidad
        function sendVelocityCommand(linear, angular) {
            if (!ros || !cmdVelTopic) {
                addLog('No hay conexion ROS disponible');
                return;
            }

            const twist = new ROSLIB.Message({
                linear: {
                    x: linear,
                    y: 0.0,
                    z: 0.0
                },
                angular: {
                    x: 0.0,
                    y: 0.0,
                    z: angular
                }
            });

            cmdVelTopic.publish(twist);

            // Actualizar display de velocidad
            document.getElementById('speedLevel').textContent = Math.abs(linear) > 0 || Math.abs(angular) > 0 ? '1' : '0';
        }

        // Controles de movimiento
        document.getElementById('moveForward').addEventListener('click', () => {
            sendVelocityCommand(0.6, 0.0);
        });

        document.getElementById('moveBackward').addEventListener('click', () => {
            sendVelocityCommand(-0.6, 0.0);
        });

        document.getElementById('turnLeft').addEventListener('click', () => {
            sendVelocityCommand(0.0, 0.5);
        });

        document.getElementById('turnRight').addEventListener('click', () => {
            sendVelocityCommand(0.0, -0.5);
        });

        document.getElementById('stopRobot').addEventListener('click', () => {
            sendVelocityCommand(0.0, 0.0);
        });

        // Control por teclado
        document.addEventListener('keydown', (event) => {
            if (!robotState.connected) return;
            
            switch(event.code) {
                case 'ArrowUp':
                    event.preventDefault();
                    sendVelocityCommand(0.2, 0.0);
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    sendVelocityCommand(-0.2, 0.0);
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    sendVelocityCommand(0.0, 0.5);
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    sendVelocityCommand(0.0, -0.5);
                    break;
            }
        });

        // Parar el robot al soltar teclas
        document.addEventListener('keyup', (event) => {
            if (!robotState.connected) return;
            
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyS', 'KeyA', 'KeyD'].includes(event.code)) {
                setTimeout(() => sendVelocityCommand(0.0, 0.0), 100);
            }
        });

        // Funciones de utilidad
        function addLog(message) {
            const logArea = document.getElementById('systemLog');
            const timestamp = new Date().toLocaleTimeString();
            logArea.innerHTML += `[${timestamp}] ${message}<br>`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        function clearLog() {
            document.getElementById('systemLog').innerHTML = 'Log limpiado...<br>';
        }

        // ===== SISTEMA DE S√çNTESIS DE VOZ =====
        
        let speechHistory = [];
        
        // Configurar eventos cuando se carga la p√°gina
        document.addEventListener('DOMContentLoaded', function() {
            setupSpeechEvents();
        });
        
        // Configurar eventos de la s√≠ntesis de voz
        function setupSpeechEvents() {
            const speechTextarea = document.getElementById('speechText');
            const charCount = document.getElementById('charCount');
            
            // Actualizar contador de caracteres
            if (speechTextarea && charCount) {
                speechTextarea.addEventListener('input', function() {
                    const currentLength = this.value.length;
                    charCount.textContent = currentLength;
                    
                    // Cambiar color seg√∫n proximidad al l√≠mite
                    if (currentLength > 450) {
                        charCount.style.color = '#dc3545'; // Rojo
                    } else if (currentLength > 400) {
                        charCount.style.color = '#ffc107'; // Amarillo
                    } else {
                        charCount.style.color = '#666'; // Gris normal
                    }
                });
                
                // Permitir env√≠o con Ctrl+Enter
                speechTextarea.addEventListener('keydown', function(e) {
                    if (e.ctrlKey && e.key === 'Enter') {
                        e.preventDefault();
                        speakText();
                    }
                });
            }
        }
        
        // Funci√≥n principal para hacer hablar al robot
        async function speakText() {
            const speechTextarea = document.getElementById('speechText');
            const speakBtn = document.getElementById('speakBtn');
            const statusIndicator = document.getElementById('speechStatus');
            const statusText = document.getElementById('speechStatusText');
            
            if (!speechTextarea || !speakBtn) {
                addLog('Error: Elementos de s√≠ntesis de voz no encontrados');
                return;
            }
            
            const text = speechTextarea.value.trim();
            
            // Validaciones
            if (!text) {
                updateSpeechStatus('‚ö†Ô∏è', 'Por favor, escribe un texto', '#ffc107');
                speechTextarea.focus();
                return;
            }
            
            if (text.length > 500) {
                updateSpeechStatus('‚ùå', 'Texto demasiado largo (m√°x. 500 caracteres)', '#dc3545');
                return;
            }
            
            if (!robotState.connected) {
                updateSpeechStatus('‚ùå', 'Robot no conectado', '#dc3545');
                addLog('‚ùå No se puede enviar comando de voz: Robot desconectado');
                return;
            }
            
            // Deshabilitar bot√≥n y mostrar estado de carga
            speakBtn.disabled = true;
            speakBtn.innerHTML = 'üîÑ Enviando...';
            updateSpeechStatus('üîÑ', 'Enviando al t√≥pico /voice...', '#17a2b8');
            
            try {
                const response = await fetch('/api/robot/speak', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ text: text })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    updateSpeechStatus('‚úÖ', 'Mensaje enviado al robot', '#28a745');
                
                    
                    // Limpiar textarea
                    speechTextarea.value = '';
                    document.getElementById('charCount').textContent = '0';
                    
                    // Volver al estado normal despu√©s de 3 segundos
                    setTimeout(() => {
                        updateSpeechStatus('‚≠ï', 'Listo para hablar', '#28a745');
                    }, 3000);
                    
                } else {
                    const errorMsg = result.error || 'Error desconocido';
                    updateSpeechStatus('‚ùå', `Error: ${errorMsg}`, '#dc3545');
                    addLog(`‚ùå Error enviando comando de voz: ${errorMsg}`);
                    
                    if (result.details) {
                        addLog(`üí° Detalles: ${result.details}`);
                    }
                }
                
            } catch (error) {
                updateSpeechStatus('‚ùå', 'Error de conexi√≥n', '#dc3545');
                addLog(`‚ùå Error de conexi√≥n al enviar comando de voz: ${error.message}`);
            } finally {
                // Rehabilitar bot√≥n
                speakBtn.disabled = false;
                speakBtn.innerHTML = 'üîä Hacer Hablar al Robot';
            }
        }
        
        // Actualizar estado visual de la s√≠ntesis de voz
        function updateSpeechStatus(icon, message, color = '#666') {
            const statusIndicator = document.getElementById('speechStatus');
            const statusText = document.getElementById('speechStatusText');
            
            if (statusIndicator) {
                statusIndicator.textContent = icon;
                statusIndicator.style.color = color;
            }
            
            if (statusText) {
                statusText.textContent = message;
                statusText.style.color = color;
            }
        }
        
        // Establecer texto predefinido en el textarea
        function setSpeechText(text) {
            const speechTextarea = document.getElementById('speechText');
            const charCount = document.getElementById('charCount');
            
            if (speechTextarea) {
                speechTextarea.value = text;
                speechTextarea.focus();
                
                // Trigger del evento input para actualizar contador
                const event = new Event('input', { bubbles: true });
                speechTextarea.dispatchEvent(event);
            }
            
            updateSpeechStatus('üìù', 'Frase predefinida seleccionada', '#17a2b8');
        }

        // ===== SISTEMA DE WAYPOINTS 3D =====
        
        // Configuraci√≥n del mapa 3D
        function initialize3DWaypoints() {
            try {
                // Verificar que Three.js est√° disponible
                if (!checkThreeJS()) {
                    setTimeout(initialize3DWaypoints, 2000);
                    return;
                }
                
                const container = document.getElementById('map3D');
                if (!container) {
                    addLog('Error: No se encontr√≥ el contenedor map3D');
                    return;
                }
                
                // Limpiar contenedor si ya tiene contenido
                while (container.children.length > 1) {
                    container.removeChild(container.lastChild);
                }
                
                addLog('Inicializando sistema de waypoints 3D...');

                // Escena
                scene3D = new THREE.Scene();
                scene3D.background = new THREE.Color(0xf5f5f5);

                // C√°mara con proporciones correctas
                const containerWidth = container.offsetWidth || 800;
                const containerHeight = 600;
                camera3D = new THREE.PerspectiveCamera(75, containerWidth / containerHeight, 0.1, 1000);
                camera3D.position.set(0, 0, 15);
                camera3D.lookAt(0, 0, 0);

                // Renderer
                renderer3D = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer3D.setSize(containerWidth, containerHeight);
                renderer3D.setClearColor(0xf5f5f5, 1);
                container.appendChild(renderer3D.domElement);

                // Luz ambiente m√°s intensa
                const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
                scene3D.add(ambientLight);
                
                // Luz direccional
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(10, 10, 5);
                scene3D.add(directionalLight);

                // Plano de referencia (grid) m√°s visible
                const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x888888);
                gridHelper.rotation.x = Math.PI / 2;
                scene3D.add(gridHelper);

                // Crear marcador del robot
                createRobotMarker3D();

                // Configurar interacci√≥n
                setupMouseInteraction3D();

                // Configurar eventos de botones
                setupWaypointControls3D();

                // Loop de renderizado
                animate3D();

                // Configurar suscripciones ROS (con delay para asegurar conexi√≥n)
                setTimeout(setupROS3DSubscriptions, 2000);

                addLog('Sistema de waypoints 3D inicializado correctamente');
                document.getElementById('mapStatus3D').textContent = 'Vista 3D lista';
                
                // Agregar plano base visible
                const planeGeometry = new THREE.PlaneGeometry(20, 20);
                const planeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xcccccc, 
                    transparent: true, 
                    opacity: 0.3 
                });
                const basePlane = new THREE.Mesh(planeGeometry, planeMaterial);
                basePlane.rotation.x = -Math.PI / 2;
                basePlane.position.z = -0.1;
                scene3D.add(basePlane);
                
            } catch (error) {
                addLog(`Error inicializando 3D: ${error.message}`);
                console.error('Error 3D:', error);
            }
        }

        // Loop de animaci√≥n 3D
        function animate3D() {
            requestAnimationFrame(animate3D);
            renderer3D.render(scene3D, camera3D);
        }

        // Crear marcador del robot en 3D
        function createRobotMarker3D() {
            try {
                // Geometr√≠a del robot (esfera m√°s grande y visible)
                const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                const material = new THREE.MeshLambertMaterial({ color: 0xff0000 });
                robotMarker3D = new THREE.Mesh(geometry, material);
                robotMarker3D.position.set(0, 0, 0.3);
                scene3D.add(robotMarker3D);
                
                // Agregar una flecha para mostrar la orientaci√≥n
                const arrowGeometry = new THREE.ConeGeometry(0.1, 0.4, 8);
                const arrowMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 });
                const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                arrow.position.set(0.4, 0, 0.3);
                arrow.rotation.z = -Math.PI / 2;
                robotMarker3D.add(arrow);
                
                addLog('Marcador 3D del robot creado (esfera roja con flecha amarilla)');
            } catch (error) {
                addLog(`Error creando marcador del robot: ${error.message}`);
            }
        }

        // Crear marcador de waypoint en 3D
        function createWaypointMarker3D(x, y, index) {
            // Cilindro para el waypoint
            const geometry = new THREE.CylinderGeometry(0.15, 0.15, 0.4, 8);
            const material = new THREE.MeshLambertMaterial({ color: 0x0066cc });
            const waypoint = new THREE.Mesh(geometry, material);
            waypoint.position.set(x, y, 0.2);

            // Crear texto simple con canvas
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 128;
            
            context.fillStyle = 'white';
            context.fillRect(0, 0, 128, 128);
            context.fillStyle = 'black';
            context.font = 'Bold 60px Arial';
            context.textAlign = 'center';
            context.fillText((index + 1).toString(), 64, 80);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(1, 1, 1);
            sprite.position.set(x, y, 0.8);

            scene3D.add(waypoint);
            scene3D.add(sprite);

            waypointMarkers3D.push({ mesh: waypoint, sprite: sprite });
            addLog(`Waypoint ${index + 1} creado en: ${x.toFixed(2)}, ${y.toFixed(2)}`);
        }

        // Configurar interacci√≥n con mouse en 3D
        function setupMouseInteraction3D() {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            renderer3D.domElement.addEventListener('click', function(event) {
                const rect = renderer3D.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera3D);

                // Intersectar con plano Z=0
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const intersectPoint = new THREE.Vector3();

                if (raycaster.ray.intersectPlane(plane, intersectPoint)) {
                    const worldX = intersectPoint.x;
                    const worldY = intersectPoint.y;

                    if (isSettingInitialPose) {
                        handleInitialPoseClick(worldX, worldY, event);
                    } else {
                        // Comportamiento normal: agregar waypoint
                        waypoints3D.push({ x: worldX, y: worldY, yaw: 0 });
                        createWaypointMarker3D(worldX, worldY, waypoints3D.length - 1);
                        updateWaypointCount3D();

                        addLog(`Waypoint a√±adido: ${worldX.toFixed(2)}, ${worldY.toFixed(2)}`);
                    }
                }
            });

            // Tambi√©n manejar movimiento del mouse para mostrar direcci√≥n en modo posici√≥n inicial
            renderer3D.domElement.addEventListener('mousemove', function(event) {
                if (isSettingInitialPose && initialPoseStep === 1) {
                    handleInitialPoseMouseMove(event);
                }
            });
        }

        // Configurar controles de waypoints
        function setupWaypointControls3D() {
            // Establecer posici√≥n inicial
            document.getElementById('setInitialPose3D').addEventListener('click', function() {
                if (isSettingInitialPose) {
                    cancelInitialPoseMode();
                } else {
                    startInitialPoseMode();
                }
            });

            // Limpiar waypoints
            document.getElementById('clearWaypoints3D').addEventListener('click', function() {
                clearWaypoints3D();
                addLog("Waypoints 3D limpiados");
            });

            // Iniciar ruta secuencial
            document.getElementById("startRoute3D").addEventListener("click", function() {
                if (waypoints3D.length === 0) {
                    addLog("No hay waypoints definidos.");
                    return;
                }

                addLog(`Iniciando ruta 3D con ${waypoints3D.length} waypoints...`);
                routeActive3D = true;
                currentWaypointIndex3D = 0;
                
                document.getElementById('startRoute3D').style.display = 'none';
                document.getElementById('nextWaypoint3D').style.display = 'inline';
                document.getElementById('nextWaypoint3D').textContent = `Enviar Primer Objetivo (1/${waypoints3D.length})`;
                document.getElementById('routeStatus3D').textContent = 'Ruta iniciada - Haz clic en "Siguiente Objetivo"';
            });

            // Siguiente waypoint
            document.getElementById("nextWaypoint3D").addEventListener("click", function() {
                if (routeActive3D) {
                    sendCurrentWaypoint3D();
                }
            });
        }

        // Configurar suscripciones ROS para waypoints 3D
        function setupROS3DSubscriptions() {
            if (!ros || !ros.isConnected) {
                addLog('Esperando conexi√≥n ROS para configurar suscripciones 3D...');
                setTimeout(setupROS3DSubscriptions, 2000);
                return;
            }

            // Suscripci√≥n al mapa
            const mapListener3D = new ROSLIB.Topic({
                ros: ros,
                name: '/map',
                messageType: 'nav_msgs/OccupancyGrid'
            });

            mapListener3D.subscribe(function(message) {
                processOccupancyGrid3D(message);
            });

            // Suscripci√≥n a pose del robot - intentar m√∫ltiples t√≥picos
            const poseListener3D = new ROSLIB.Topic({
                ros: ros,
                name: '/amcl_pose',
                messageType: 'geometry_msgs/PoseWithCovarianceStamped'
            });

            poseListener3D.subscribe(function(message) {
                updateRobotPosition3D(message);
            });

            // Fallback: tambi√©n intentar con /robot_pose_ekf/odom_combined
            const poseListenerAlt = new ROSLIB.Topic({
                ros: ros,
                name: '/robot_pose_ekf/odom_combined',
                messageType: 'geometry_msgs/PoseWithCovarianceStamped'
            });

            poseListenerAlt.subscribe(function(message) {
                updateRobotPosition3D(message);
            });

            // Tambi√©n usar datos de odometr√≠a para actualizar posici√≥n del robot en 3D
            if (odomTopic) {
                // Simplemente agregar callback sin acceder a _callbacks interno
                odomTopic.subscribe(function(message) {
                    // Actualizar tambi√©n en el mapa 3D
                    updateRobotPositionFromOdom3D(message);
                });
            }

            addLog('Suscripciones 3D configuradas correctamente');
        }

        // Actualizar posici√≥n del robot en 3D
        function updateRobotPosition3D(message) {
            if (robotMarker3D && message.pose && message.pose.pose) {
                const now = Date.now();
                
                // Si acabamos de establecer una posici√≥n inicial (hace menos de 5 segundos), no actualizar
                if (now - lastInitialPoseTime < 5000) {
                    return;
                }
                
                const pos = message.pose.pose.position;
                const ori = message.pose.pose.orientation;

                robotMarker3D.position.set(pos.x, pos.y, 0.2);

                // Calcular yaw desde quaternion
                const q = ori;
                const siny_cosp = 2 * (q.w * q.z + q.x * q.y);
                const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
                const yaw = Math.atan2(siny_cosp, cosy_cosp);

                robotMarker3D.rotation.z = yaw;

                document.getElementById('robotPos3D').textContent = 
                    `X: ${pos.x.toFixed(2)}, Y: ${pos.y.toFixed(2)}`;
            }
        }

        // Actualizar posici√≥n del robot desde odometr√≠a
        function updateRobotPositionFromOdom3D(message) {
            if (robotMarker3D && message.pose && message.pose.pose) {
                const now = Date.now();
                
                // Si acabamos de establecer una posici√≥n inicial (hace menos de 5 segundos), no actualizar
                if (now - lastInitialPoseTime < 5000) {
                    return;
                }
                
                const pos = message.pose.pose.position;
                const ori = message.pose.pose.orientation;

                robotMarker3D.position.set(pos.x, pos.y, 0.2);

                // Calcular yaw desde quaternion
                const q = ori;
                const siny_cosp = 2 * (q.w * q.z + q.x * q.y);
                const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
                const yaw = Math.atan2(siny_cosp, cosy_cosp);

                robotMarker3D.rotation.z = yaw;

                document.getElementById('robotPos3D').textContent = 
                    `X: ${pos.x.toFixed(2)}, Y: ${pos.y.toFixed(2)}`;
            }
        }

        // Procesar mapa de ocupaci√≥n en 3D
        function processOccupancyGrid3D(message) {
            try {
                if (!message || !message.info) {
                    addLog('Mensaje de mapa 3D inv√°lido recibido');
                    return;
                }
                
                addLog(`Mapa 3D recibido: ${message.info.width}x${message.info.height} (resoluci√≥n: ${message.info.resolution}m/px)`);
                
                // Actualizar configuraci√≥n
                mapConfig3D.resolution = message.info.resolution;
                mapConfig3D.originX = message.info.origin.position.x;
                mapConfig3D.originY = message.info.origin.position.y;
                mapConfig3D.width = message.info.width * mapConfig3D.resolution;
                mapConfig3D.height = message.info.height * mapConfig3D.resolution;

                // Crear geometr√≠a del mapa
                createMapGeometry3D(message);
                
                document.getElementById('mapStatus3D').textContent = 
                    `Mapa: ${message.info.width}x${message.info.height} (${mapConfig3D.resolution.toFixed(3)}m/px)`;
                    
            } catch (error) {
                addLog(`Error procesando mapa 3D: ${error.message}`);
                console.error('Error procesando mapa 3D:', error);
            }
        }

        // Crear geometr√≠a del mapa en 3D
        function createMapGeometry3D(mapData) {
            // Remover mapa anterior si existe
            if (mapPlane3D) {
                scene3D.remove(mapPlane3D);
            }

            // Crear textura del mapa
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = mapData.info.width;
            canvas.height = mapData.info.height;

            const imageData = context.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < mapData.data.length; i++) {
                const value = mapData.data[i];
                let color = 128; // Gris por defecto
                
                if (value >= 0 && value <= 100) {
                    color = 255 - Math.floor((value / 100) * 255);
                }
                
                const pixelIndex = i * 4;
                data[pixelIndex] = color;     // R
                data[pixelIndex + 1] = color; // G
                data[pixelIndex + 2] = color; // B
                data[pixelIndex + 3] = 255;   // A
            }

            context.putImageData(imageData, 0, 0);

            // Crear plano con la textura del mapa
            const texture = new THREE.CanvasTexture(canvas);
            texture.flipY = false;
            
            const geometry = new THREE.PlaneGeometry(mapConfig3D.width, mapConfig3D.height);
            const material = new THREE.MeshBasicMaterial({ map: texture });
            mapPlane3D = new THREE.Mesh(geometry, material);
            mapPlane3D.position.set(
                mapConfig3D.originX + mapConfig3D.width / 2,
                mapConfig3D.originY + mapConfig3D.height / 2,
                -0.01
            );
            
            scene3D.add(mapPlane3D);
            addLog('Geometr√≠a del mapa 3D creada');
        }

        // Enviar waypoint actual
        function sendCurrentWaypoint3D() {
            if (currentWaypointIndex3D >= waypoints3D.length) {
                // Ruta completada
                routeActive3D = false;
                document.getElementById('startRoute3D').style.display = 'inline';
                document.getElementById('nextWaypoint3D').style.display = 'none';
                document.getElementById('routeStatus3D').textContent = 'Ruta completada!';
                addLog('Ruta 3D completada!');
                return;
            }

            const wp = waypoints3D[currentWaypointIndex3D];
            const goal = new ROSLIB.Message({
                header: {
                    frame_id: 'map',
                    stamp: {
                        sec: 0,
                        nsec: 0
                    }
                },
                pose: {
                    position: { x: wp.x, y: wp.y, z: 0 },
                    orientation: {
                        x: 0,
                        y: 0,
                        z: Math.sin(wp.yaw / 2),
                        w: Math.cos(wp.yaw / 2)
                    }
                }
            });

            goalTopic3D.publish(goal);
            addLog(`Enviado waypoint 3D ${currentWaypointIndex3D + 1} de ${waypoints3D.length}: (${wp.x.toFixed(2)}, ${wp.y.toFixed(2)})`);
            
            document.getElementById('routeStatus3D').textContent = 
                `Objetivo ${currentWaypointIndex3D + 1} de ${waypoints3D.length} enviado`;
            
            currentWaypointIndex3D++;
            
            if (currentWaypointIndex3D >= waypoints3D.length) {
                document.getElementById('nextWaypoint3D').textContent = 'Finalizar Ruta';
            } else {
                document.getElementById('nextWaypoint3D').textContent = `Siguiente Objetivo (${currentWaypointIndex3D + 1}/${waypoints3D.length})`;
            }
        }

        // Limpiar waypoints 3D
        function clearWaypoints3D() {
            waypointMarkers3D.forEach(function(marker) {
                scene3D.remove(marker.mesh);
                scene3D.remove(marker.sprite);
            });
            waypointMarkers3D = [];
            waypoints3D = [];
            currentWaypointIndex3D = 0;
            routeActive3D = false;
            document.getElementById('startRoute3D').style.display = 'inline';
            document.getElementById('nextWaypoint3D').style.display = 'none';
            document.getElementById('routeStatus3D').textContent = '';
            updateWaypointCount3D();
        }

        // Actualizar contador de waypoints 3D
        function updateWaypointCount3D() {
            const count = waypoints3D.length;
            document.getElementById('waypointCount3D').textContent = count;
            document.getElementById('waypointDisplay3D').textContent = count;
        }

        // ========== FUNCIONES DE POSICI√ìN INICIAL ==========
        
        // Variables para posici√≥n inicial
        let initialPosePosition = null;
        let initialPoseArrow = null;
        let lastInitialPoseTime = 0; // Para evitar actualizaciones de odometr√≠a despu√©s de initialpose
        let initialPoseMarkers = []; // Array para almacenar todos los marcadores de posici√≥n inicial
        
        // Limpiar marcadores de initial pose anteriores
        function clearInitialPoseMarkers() {
            initialPoseMarkers.forEach(marker => {
                scene3D.remove(marker);
            });
            initialPoseMarkers.length = 0;
        }
        
        // Iniciar modo de establecimiento de posici√≥n inicial
        function startInitialPoseMode() {
            if (!ros || !ros.isConnected) {
                addLog('‚ùå No hay conexi√≥n ROS para establecer posici√≥n inicial');
                updateInitialPoseStatus('‚ùå Sin conexi√≥n ROS', 'error');
                return;
            }

            if (!initialPoseTopic3D) {
                addLog('‚ùå T√≥pico /initialpose no est√° configurado');
                updateInitialPoseStatus('‚ùå T√≥pico no configurado', 'error');
                return;
            }
            
            // Limpiar marcadores de posici√≥n inicial anteriores
            clearInitialPoseMarkers();
            
            isSettingInitialPose = true;
            initialPoseStep = 0;
            
            // Cambiar apariencia del bot√≥n
            const btn = document.getElementById('setInitialPose3D');
            btn.style.background = '#dc3545';
            btn.textContent = '‚ùå Cancelar Posici√≥n Inicial';
            
            // Cambiar cursor del mapa
            renderer3D.domElement.style.cursor = 'crosshair';
            
            updateInitialPoseStatus('üìç Haz clic en el mapa para establecer posici√≥n', 'info');
            addLog('üìç Modo posici√≥n inicial activado - Haz clic para establecer posici√≥n');
            addLog('‚ÑπÔ∏è  IMPORTANTE: Aseg√∫rate de que AMCL est√© ejecut√°ndose para que el robot se mueva');
        }
        
        // Cancelar modo de posici√≥n inicial
        function cancelInitialPoseMode() {
            isSettingInitialPose = false;
            initialPoseStep = 0;
            initialPosePosition = null;
            
            // Limpiar marcadores temporales
            clearInitialPoseMarkers();
            
            // Restaurar bot√≥n
            const btn = document.getElementById('setInitialPose3D');
            btn.style.background = '#17a2b8';
            btn.textContent = 'üìç Establecer Posici√≥n Inicial';
            
            // Restaurar cursor
            renderer3D.domElement.style.cursor = 'default';
            
            updateInitialPoseStatus('', 'info');
            addLog('üìç Modo posici√≥n inicial cancelado');
        }
        
        // Manejar clic para posici√≥n inicial
        function handleInitialPoseClick(worldX, worldY, event) {
            if (initialPoseStep === 0) {
                // Primer clic: establecer posici√≥n
                initialPosePosition = { x: worldX, y: worldY };
                initialPoseStep = 1;
                
                // Crear marcador temporal de posici√≥n
                createInitialPosePositionMarker(worldX, worldY);
                
                updateInitialPoseStatus('üß≠ Ahora haz clic para establecer la direcci√≥n (heading)', 'info');
                addLog(`üìç Posici√≥n establecida en: ${worldX.toFixed(2)}, ${worldY.toFixed(2)}`);
                
            } else if (initialPoseStep === 1) {
                // Segundo clic: establecer direcci√≥n
                const heading = calculateHeading(initialPosePosition.x, initialPosePosition.y, worldX, worldY);
                
                // Publicar posici√≥n inicial
                publishInitialPose(initialPosePosition.x, initialPosePosition.y, heading);
                
                // Finalizar modo
                cancelInitialPoseMode();
            }
        }
        
        // Manejar movimiento del mouse para mostrar preview de direcci√≥n
        function handleInitialPoseMouseMove(event) {
            if (!initialPosePosition) return;
            
            const rect = renderer3D.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera3D);
            
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            const intersectPoint = new THREE.Vector3();
            
            if (raycaster.ray.intersectPlane(plane, intersectPoint)) {
                updateInitialPoseArrow(initialPosePosition.x, initialPosePosition.y, intersectPoint.x, intersectPoint.y);
            }
        }
        
        // Calcular heading (√°ngulo) entre dos puntos
        function calculateHeading(x1, y1, x2, y2) {
            return Math.atan2(y2 - y1, x2 - x1);
        }
        
        // Crear marcador de posici√≥n inicial
        function createInitialPosePositionMarker(x, y) {
            // Limpiar marcadores previos
            clearInitialPoseMarkers();
            
            // Crear esfera para la posici√≥n
            const geometry = new THREE.SphereGeometry(0.2, 16, 16);
            const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            initialPosePosition.marker = new THREE.Mesh(geometry, material);
            initialPosePosition.marker.position.set(x, y, 0.2);
            scene3D.add(initialPosePosition.marker);
            
            // Agregar al array de marcadores para poder limpiarlo despu√©s
            initialPoseMarkers.push(initialPosePosition.marker);
        }
        
        // Actualizar flecha de direcci√≥n
        function updateInitialPoseArrow(x1, y1, x2, y2) {
            // Limpiar flecha previa del array si existe
            if (initialPoseArrow) {
                scene3D.remove(initialPoseArrow);
                // Remover del array si existe
                const index = initialPoseMarkers.indexOf(initialPoseArrow);
                if (index > -1) {
                    initialPoseMarkers.splice(index, 1);
                }
            }
            
            const heading = calculateHeading(x1, y1, x2, y2);
            const arrowLength = 1.0;
            
            // Crear geometr√≠a de flecha
            const arrowGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
            const arrowMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            initialPoseArrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            
            // Posicionar la flecha
            const endX = x1 + Math.cos(heading) * arrowLength;
            const endY = y1 + Math.sin(heading) * arrowLength;
            initialPoseArrow.position.set(endX, endY, 0.3);
            initialPoseArrow.rotation.z = heading - Math.PI / 2; // Ajustar rotaci√≥n
            
            scene3D.add(initialPoseArrow);
            
            // Agregar al array de marcadores
            initialPoseMarkers.push(initialPoseArrow);
        }
        
        // Publicar posici√≥n inicial en el t√≥pico /initialpose
        function publishInitialPose(x, y, heading) {
            if (!initialPoseTopic3D) {
                addLog('‚ùå T√≥pico /initialpose no configurado');
                updateInitialPoseStatus('‚ùå Error: T√≥pico no configurado', 'error');
                return;
            }

            if (!ros || !ros.isConnected) {
                addLog('‚ùå ROS no est√° conectado, no se puede enviar initialpose');
                updateInitialPoseStatus('‚ùå Error: ROS desconectado', 'error');
                return;
            }
            
            // Convertir heading a quaternion
            const quaternion = headingToQuaternion(heading);
            
            // Actualizar inmediatamente la posici√≥n visual del robot
            if (robotMarker3D) {
                robotMarker3D.position.set(x, y, 0.2);
                robotMarker3D.rotation.z = heading;
                
                // Actualizar tambi√©n el display de posici√≥n
                document.getElementById('robotPos3D').textContent = 
                    `X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}`;
                
                addLog(`ü§ñ Robot movido visualmente a: X=${x.toFixed(2)}, Y=${y.toFixed(2)}, Heading=${(heading * 180 / Math.PI).toFixed(1)}¬∞`);
            }
            
            // Crear mensaje de posici√≥n inicial
            const initialPoseMsg = new ROSLIB.Message({
                header: {
                    frame_id: 'map',
                    stamp: {
                        secs: Math.floor(Date.now() / 1000),
                        nsecs: (Date.now() % 1000) * 1000000
                    }
                },
                pose: {
                    pose: {
                        position: {
                            x: x,
                            y: y,
                            z: 0.0
                        },
                        orientation: {
                            x: quaternion.x,
                            y: quaternion.y,
                            z: quaternion.z,
                            w: quaternion.w
                        }
                    },
                    covariance: [
                        0.25, 0.0, 0.0, 0.0, 0.0, 0.0,
                        0.0, 0.25, 0.0, 0.0, 0.0, 0.0,
                        0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                        0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                        0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
                        0.0, 0.0, 0.0, 0.0, 0.0, 0.06853892326654787
                    ]
                }
            });
            
            try {
                // Publicar el mensaje
                initialPoseTopic3D.publish(initialPoseMsg);
                
                updateInitialPoseStatus('‚úÖ Posici√≥n inicial establecida correctamente', 'success');
                addLog(`‚úÖ Posici√≥n inicial publicada en /initialpose: X=${x.toFixed(2)}, Y=${y.toFixed(2)}, Heading=${(heading * 180 / Math.PI).toFixed(1)}¬∞`);
                addLog(`üì° Mensaje enviado - frame_id: map, timestamp: ${initialPoseMsg.header.stamp.secs}.${initialPoseMsg.header.stamp.nsecs}`);
                
                // Verificar si AMCL est√° escuchando
                setTimeout(() => {
                    addLog(`‚ÑπÔ∏è  Si el robot no se mueve, verifica que AMCL est√© ejecut√°ndose y suscrito a /initialpose`);
                    addLog(`‚ÑπÔ∏è  Tambi√©n puedes verificar los t√≥picos con: rostopic list | grep initialpose`);
                }, 1000);
                
            } catch (error) {
                const errorMsg = `Error publicando initialpose: ${error.message}`;
                addLog(`‚ùå ${errorMsg}`);
                updateInitialPoseStatus('‚ùå Error enviando posici√≥n', 'error');
            }
        }
        
        // Convertir heading (radianes) a quaternion
        function headingToQuaternion(heading) {
            const halfYaw = heading * 0.5;
            return {
                x: 0,
                y: 0,
                z: Math.sin(halfYaw),
                w: Math.cos(halfYaw)
            };
        }
        
        // Actualizar estado de posici√≥n inicial
        function updateInitialPoseStatus(message, type = 'info') {
            const statusElement = document.getElementById('initialPoseStatus3D');
            if (!statusElement) return;
            
            statusElement.textContent = message;
            
            // Colores seg√∫n el tipo
            const colors = {
                info: '#17a2b8',
                success: '#28a745',
                error: '#dc3545',
                warning: '#ffc107'
            };
            
            statusElement.style.color = colors[type] || colors.info;
        }

        // Limpiar conexiones al cerrar la p√°gina
        window.addEventListener('beforeunload', () => {
            if (ros) {
                sendVelocityCommand(0.0, 0.0); // Parar el robot
                
                // Limpiar suscripci√≥n del mapa
                if (mapTopic) {
                    mapTopic.unsubscribe();
                }
                
                ros.close();
            }
        });

        // ========== SISTEMA DE ZONAS ==========

        // Abrir modal de zonas
        function openZonesModal() {
            zonesModal = document.getElementById('zonesModal');
            
            if (!zonesModal) {
                console.error('Modal de zonas no encontrado');
                return;
            }
            
            zonesModal.style.display = 'block';
            
            // Suscribirse al mapa de ROS si est√° conectado
            if (ros && ros.isConnected) {
                setupZonesMapSubscription();
            }
            
            // Esperar a que el modal se renderice completamente antes de inicializar el canvas
            setTimeout(() => {
                // Inicializar canvas solo una vez
                if (!zonesCanvas) {
                    initializeZonesCanvas();
                } else {
                    // Si ya existe, redimensionar y redibujar
                    resizeZonesCanvas();
                    drawMapBackground();
                }
                
                loadSavedZones();
            }, 100); // Peque√±o delay para asegurar el renderizado
        }

        // Cerrar modal de zonas
        function closeZonesModal() {
            if (zonesModal) {
                zonesModal.style.display = 'none';
            }
            
            // Desuscribirse del mapa
            if (zonesMapTopic) {
                zonesMapTopic.unsubscribe();
                zonesMapTopic = null;
            }
            
            // Limpiar zona actual
            clearCurrentZone();
        }

        // Configurar suscripci√≥n al mapa para zonas
        function setupZonesMapSubscription() {
            if (!ros || !ros.isConnected) {
                return;
            }

            // Desuscribirse si ya existe
            if (zonesMapTopic) {
                zonesMapTopic.unsubscribe();
            }

            // Crear nueva suscripci√≥n al mapa
            zonesMapTopic = new ROSLIB.Topic({
                ros: ros,
                name: '/map',
                messageType: 'nav_msgs/OccupancyGrid'
            });

            zonesMapTopic.subscribe(function(message) {
                processZonesMapData(message);
            });
        }

        // Procesar datos del mapa para zonas
        function processZonesMapData(mapMessage) {
            try {
                if (!mapMessage || !mapMessage.info) {
                    console.error('Mensaje de mapa inv√°lido para zonas:', mapMessage);
                    return;
                }

                zonesMapData = mapMessage;
                zonesMapConfig.resolution = mapMessage.info.resolution;
                zonesMapConfig.originX = mapMessage.info.origin.position.x;
                zonesMapConfig.originY = mapMessage.info.origin.position.y;
                zonesMapConfig.width = mapMessage.info.width * zonesMapConfig.resolution;
                zonesMapConfig.height = mapMessage.info.height * zonesMapConfig.resolution;

                // Redibujar el canvas con el nuevo mapa
                if (zonesCanvas && zonesContext) {
                    drawMapBackground();
                }
            } catch (error) {
                console.error('Error procesando mapa para zonas:', error);
            }
        }

        // Inicializar canvas para dibujo de zonas
        function initializeZonesCanvas() {
            zonesCanvas = document.getElementById('zonesCanvas');
            if (!zonesCanvas) {
                console.error('Canvas de zonas no encontrado');
                return;
            }
            
            zonesContext = zonesCanvas.getContext('2d');
            
            // Configurar tama√±o del canvas
            resizeZonesCanvas();
            
            // Event listeners para el dibujo de zonas por puntos
            zonesCanvas.addEventListener('click', startDrawing);
            zonesCanvas.addEventListener('mousemove', updateDrawing);
            zonesCanvas.addEventListener('mouseleave', cancelDrawing);
            
            
            
            // Dibujar fondo inicial
            drawMapBackground();
            }

        // Redimensionar canvas
        function resizeZonesCanvas() {
            if (!zonesCanvas) return;
            
            const container = zonesCanvas.parentElement;
            if (!container) {
                console.error('Contenedor del canvas no encontrado');
                return;
            }
            
            // Obtener dimensiones del contenedor con un peque√±o margen para evitar scroll
            const rect = container.getBoundingClientRect();
            
            // Asegurar que el canvas use exactamente el espacio disponible del contenedor
            const availableWidth = rect.width - 10; // Peque√±o margen para borders/padding
            const availableHeight = rect.height - 10;
            
            // Asegurar dimensiones m√≠nimas pero tambi√©n m√°ximas para que no desborden
            zonesCanvas.width = Math.max(Math.min(availableWidth, rect.width - 4), 300);
            zonesCanvas.height = Math.max(Math.min(availableHeight, rect.height - 4), 200);
        }

        // Dibujar fondo del mapa
        function drawMapBackground() {
            
            if (!zonesCanvas || !zonesContext) {
                console.error('Canvas o contexto no inicializado');
                return;
            }
            
            // Verificar que el canvas tenga dimensiones v√°lidas
            if (zonesCanvas.width === 0 || zonesCanvas.height === 0) {
                console.error('Canvas con dimensiones inv√°lidas');
                return;
            }
            
            // Limpiar canvas
            zonesContext.clearRect(0, 0, zonesCanvas.width, zonesCanvas.height);
            
            // Si tenemos datos del mapa, dibujarlos
            if (zonesMapData) {
                drawROSMap();
            } else {
                console.log('No hay datos de mapa, dibujando fondo por defecto...');
                // Dibujar fondo por defecto
                zonesContext.fillStyle = '#f0f0f0';
                zonesContext.fillRect(0, 0, zonesCanvas.width, zonesCanvas.height);
                console.log('Fondo dibujado');
                
                // Dibujar grid
                drawGrid();
            }
            
            // Redibujar zonas guardadas
            redrawSavedZones();
            
            console.log('drawMapBackground completado');
        }

        // Dibujar mapa de ROS en el canvas
        function drawROSMap() {
            try {
                const mapInfo = zonesMapData.info;
                const mapWidth = mapInfo.width;
                const mapHeight = mapInfo.height;
                
                console.log(`Dibujando mapa ROS: ${mapWidth}x${mapHeight}`);
                
                // Crear imagen del mapa
                const imageData = zonesContext.createImageData(zonesCanvas.width, zonesCanvas.height);
                const data = imageData.data;
                
                // Calcular escalas para ajustar el mapa al canvas
                const scaleX = zonesCanvas.width / mapWidth;
                const scaleY = zonesCanvas.height / mapHeight;
                
                console.log(`Escalas: X=${scaleX.toFixed(2)}, Y=${scaleY.toFixed(2)}`);
                
                // Llenar con color de fondo
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 245;     // R
                    data[i + 1] = 245; // G  
                    data[i + 2] = 245; // B
                    data[i + 3] = 255; // A
                }
                
                // Dibujar datos del mapa
                for (let canvasY = 0; canvasY < zonesCanvas.height; canvasY++) {
                    for (let canvasX = 0; canvasX < zonesCanvas.width; canvasX++) {
                        // Convertir coordenadas del canvas a coordenadas del mapa
                        const mapX = Math.floor(canvasX / scaleX);
                        const mapY = Math.floor((zonesCanvas.height - canvasY - 1) / scaleY); // Invertir Y
                        
                        if (mapX >= 0 && mapX < mapWidth && mapY >= 0 && mapY < mapHeight) {
                            const mapIndex = mapY * mapWidth + mapX;
                            const occupancyValue = zonesMapData.data[mapIndex];
                            
                            let color = 245; // Gris claro por defecto (√°rea desconocida)
                            
                            if (occupancyValue >= 0 && occupancyValue <= 100) {
                                // 0 = libre (blanco), 100 = ocupado (negro)
                                color = 255 - Math.floor((occupancyValue / 100) * 255);
                            }
                            
                            const pixelIndex = (canvasY * zonesCanvas.width + canvasX) * 4;
                            data[pixelIndex] = color;     // R
                            data[pixelIndex + 1] = color; // G
                            data[pixelIndex + 2] = color; // B
                            data[pixelIndex + 3] = 255;   // A
                        }
                    }
                }
                
                // Aplicar la imagen al canvas
                zonesContext.putImageData(imageData, 0, 0);
                console.log('Mapa ROS dibujado exitosamente');
                
                // Dibujar grid sutil sobre el mapa
                drawGrid(true);
                
            } catch (error) {
                console.error('Error dibujando mapa ROS:', error);
                // Fallback a fondo por defecto
                zonesContext.fillStyle = '#f0f0f0';
                zonesContext.fillRect(0, 0, zonesCanvas.width, zonesCanvas.height);
                drawGrid();
            }
        }

        // Dibujar grid
        function drawGrid(subtle = false) {
            console.log('Dibujando grid...');
            
            zonesContext.strokeStyle = subtle ? 'rgba(200, 200, 200, 0.3)' : '#ddd';
            zonesContext.lineWidth = 1;
            
            const gridSize = 20;
            
            // L√≠neas verticales
            for (let x = 0; x < zonesCanvas.width; x += gridSize) {
                zonesContext.beginPath();
                zonesContext.moveTo(x, 0);
                zonesContext.lineTo(x, zonesCanvas.height);
                zonesContext.stroke();
            }
            
            // L√≠neas horizontales
            for (let y = 0; y < zonesCanvas.height; y += gridSize) {
                zonesContext.beginPath();
                zonesContext.moveTo(0, y);
                zonesContext.lineTo(zonesCanvas.width, y);
                zonesContext.stroke();
            }
        }

        // Manejar clic en el canvas para agregar puntos de la zona
        function handleZoneClick(event) {
            if (!zonesCanvas) return;
            
            const rect = zonesCanvas.getBoundingClientRect();
            const clickPoint = {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
            
            // Agregar el punto al array
            zonePoints.push(clickPoint);
            currentPointIndex++;
            
            // Redibujar el canvas con los puntos actuales
            drawMapBackground();
            drawCurrentZone();
            
            if (currentPointIndex < 4) {
                updateZoneStatus(`Punto ${currentPointIndex} agregado. Haz clic para agregar punto ${currentPointIndex + 1}/4`, 'info');
            } else {
                // Ya tenemos 4 puntos, crear la zona
                currentZone = createPolygonZone(zonePoints);
                isDrawingZone = false;
                
                // Habilitar botones
                document.getElementById('saveZoneBtn').disabled = false;
                document.getElementById('clearZoneBtn').disabled = false;
                
                updateZoneStatus('Zona de 4 puntos creada. Asigna nombre y color, luego guarda.', 'success');
            }
        }

        // Iniciar dibujo de zona (nueva versi√≥n para pol√≠gonos)
        function startDrawing(event) {
            if (!isDrawingZone) {
                // Iniciar nueva zona
                zonePoints = [];
                currentPointIndex = 0;
                isDrawingZone = true;
                zonesCanvas.classList.add('zone-drawing');
                updateZoneStatus('Haz clic en el primer punto (1/4)', 'info');
            }
            
            // Manejar el clic como un punto de la zona
            handleZoneClick(event);
        }

        // Actualizar posici√≥n del mouse (para mostrar preview del pr√≥ximo punto)
        function updateDrawing(event) {
            if (!isDrawingZone || currentPointIndex >= 4) return;
            
            const rect = zonesCanvas.getBoundingClientRect();
            mousePosition = {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
            
            // Redibujar canvas con preview del pr√≥ximo punto
            drawMapBackground();
            drawCurrentZone();
        }

        // Esta funci√≥n ya no es necesaria para clics, pero la mantenemos para compatibilidad
        function finishDrawing(event) {
            // No hacer nada, el proceso se completa en handleZoneClick
        }

        // Cancelar dibujo
        function cancelDrawing() {
            if (isDrawingZone) {
                isDrawingZone = false;
                zonePoints = [];
                currentPointIndex = 0;
                zonesCanvas.classList.remove('zone-drawing');
                drawMapBackground();
                updateZoneStatus('Dibujo cancelado. Haz clic para empezar una nueva zona.', 'info');
            }
        }

        // Crear zona poligonal a partir de 4 puntos
        function createPolygonZone(points) {
            if (points.length !== 4) {
                console.error('Se requieren exactamente 4 puntos para crear una zona');
                return null;
            }
            
            return {
                points: [...points], // Copiar array de puntos
                color: document.getElementById('zoneColor').value,
                name: '',
                type: 'polygon'
            };
        }

        // Funci√≥n legacy para compatibilidad (no se usa m√°s)
        function createRectangularZone(start, end) {
            const minX = Math.min(start.x, end.x);
            const minY = Math.min(start.y, end.y);
            const maxX = Math.max(start.x, end.x);
            const maxY = Math.max(start.y, end.y);
            
            // Convertir rect√°ngulo a 4 puntos para compatibilidad
            return {
                points: [
                    { x: minX, y: minY },
                    { x: maxX, y: minY },
                    { x: maxX, y: maxY },
                    { x: minX, y: maxY }
                ],
                color: document.getElementById('zoneColor').value,
                name: '',
                type: 'polygon'
            };
        }

        // Dibujar zona actual (pol√≠gono en construcci√≥n o completo)
        function drawCurrentZone() {
            if (currentZone) {
                // Zona completada
                drawZone(currentZone);
            } else if (isDrawingZone && zonePoints.length > 0) {
                // Zona en construcci√≥n
                const tempColor = document.getElementById('zoneColor').value;
                
                // Dibujar puntos ya colocados
                zonePoints.forEach((point, index) => {
                    drawPoint(point, index + 1, tempColor);
                });
                
                // Dibujar l√≠neas conectando los puntos
                if (zonePoints.length > 1) {
                    drawConnectingLines(zonePoints, tempColor, 0.5);
                }
                
                // Dibujar l√≠nea desde el √∫ltimo punto hasta la posici√≥n del mouse
                if (zonePoints.length > 0 && currentPointIndex < 4) {
                    drawPreviewLine(zonePoints[zonePoints.length - 1], mousePosition, tempColor);
                }
                
                // Si tenemos 3 puntos, mostrar preview de cierre
                if (zonePoints.length === 3) {
                    drawPreviewLine(mousePosition, zonePoints[0], tempColor);
                }
            }
        }

        // Dibujar un punto numerado
        function drawPoint(point, number, color) {
            zonesContext.fillStyle = color;
            zonesContext.beginPath();
            zonesContext.arc(point.x, point.y, 8, 0, 2 * Math.PI);
            zonesContext.fill();
            
            // Borde blanco
            zonesContext.strokeStyle = 'white';
            zonesContext.lineWidth = 2;
            zonesContext.stroke();
            
            // N√∫mero del punto
            zonesContext.fillStyle = 'white';
            zonesContext.font = '12px Arial';
            zonesContext.textAlign = 'center';
            zonesContext.fillText(number.toString(), point.x, point.y + 4);
        }

        // Dibujar l√≠neas conectando puntos
        function drawConnectingLines(points, color, alpha = 1.0) {
            if (points.length < 2) return;
            
            zonesContext.globalAlpha = alpha;
            zonesContext.strokeStyle = color;
            zonesContext.lineWidth = 2;
            zonesContext.setLineDash([]);
            
            zonesContext.beginPath();
            zonesContext.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                zonesContext.lineTo(points[i].x, points[i].y);
            }
            
            // Si tenemos 4 puntos, cerrar el pol√≠gono
            if (points.length === 4) {
                zonesContext.closePath();
            }
            
            zonesContext.stroke();
            zonesContext.globalAlpha = 1.0;
        }

        // Dibujar l√≠nea de preview
        function drawPreviewLine(fromPoint, toPoint, color) {
            zonesContext.globalAlpha = 0.5;
            zonesContext.strokeStyle = color;
            zonesContext.lineWidth = 1;
            zonesContext.setLineDash([5, 5]);
            
            zonesContext.beginPath();
            zonesContext.moveTo(fromPoint.x, fromPoint.y);
            zonesContext.lineTo(toPoint.x, toPoint.y);
            zonesContext.stroke();
            
            zonesContext.setLineDash([]);
            zonesContext.globalAlpha = 1.0;
        }

        // Dibujar una zona en el canvas (pol√≠gono o rect√°ngulo)
        function drawZone(zone, isTemporary = false) {
            console.log('Dibujando zona:', zone, 'isTemporary:', isTemporary);
            
            if (!zone || !zone.color) {
                console.error('Zona inv√°lida para dibujar:', zone);
                return;
            }
            
            const alpha = isTemporary ? 0.3 : 0.5;
            
            try {
                if (zone.type === 'polygon' && zone.points && zone.points.length === 4) {
                    // Dibujar pol√≠gono de 4 puntos
                    drawPolygonZone(zone, alpha, isTemporary);
                } else if (zone.x !== undefined && zone.y !== undefined && zone.width !== undefined && zone.height !== undefined) {
                    // Compatibilidad: dibujar rect√°ngulo legacy
                    drawRectangularZone(zone, alpha, isTemporary);
                } else {
                    console.error('Formato de zona no reconocido:', zone);
                }
            } catch (error) {
                console.error('Error dibujando zona:', error);
            }
        }

        // Dibujar zona poligonal
        function drawPolygonZone(zone, alpha, isTemporary) {
            const points = zone.points;
            
            // Rellenar pol√≠gono
            zonesContext.globalAlpha = alpha;
            zonesContext.fillStyle = zone.color;
            zonesContext.beginPath();
            zonesContext.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                zonesContext.lineTo(points[i].x, points[i].y);
            }
            
            zonesContext.closePath();
            zonesContext.fill();
            
            // Restaurar alpha para el borde
            zonesContext.globalAlpha = 1.0;
            
            // Borde del pol√≠gono
            zonesContext.strokeStyle = zone.color;
            zonesContext.lineWidth = 2;
            zonesContext.beginPath();
            zonesContext.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                zonesContext.lineTo(points[i].x, points[i].y);
            }
            
            zonesContext.closePath();
            zonesContext.stroke();
            
            // Dibujar puntos numerados si no es temporal
            if (!isTemporary) {
                points.forEach((point, index) => {
                    drawPoint(point, index + 1, zone.color);
                });
            }
            
            // Nombre de la zona en el centro del pol√≠gono
            if (!isTemporary && zone.name) {
                const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
                const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
                
                zonesContext.fillStyle = '#000';
                zonesContext.font = '12px Arial';
                zonesContext.textAlign = 'center';
                
                // Fondo para el texto
                const textWidth = zonesContext.measureText(zone.name).width;
                zonesContext.fillStyle = 'rgba(255, 255, 255, 0.8)';
                zonesContext.fillRect(centerX - textWidth/2 - 5, centerY - 10, textWidth + 10, 20);
                
                // Texto
                zonesContext.fillStyle = '#000';
                zonesContext.fillText(zone.name, centerX, centerY + 3);
            }
        }

        // Dibujar zona rectangular (compatibilidad con formato legacy)
        function drawRectangularZone(zone, alpha, isTemporary) {
            // Rellenar zona con transparencia
            zonesContext.fillStyle = zone.color;
            zonesContext.globalAlpha = alpha;
            zonesContext.fillRect(zone.x, zone.y, zone.width, zone.height);
            
            // Restaurar alpha para el borde
            zonesContext.globalAlpha = 1.0;
            
            // Borde de la zona
            zonesContext.strokeStyle = zone.color;
            zonesContext.lineWidth = 2;
            zonesContext.strokeRect(zone.x, zone.y, zone.width, zone.height);
            
            // Nombre de la zona (solo si no es temporal y tiene nombre)
            if (!isTemporary && zone.name) {
                zonesContext.fillStyle = '#000';
                zonesContext.font = '12px Arial';
                zonesContext.textAlign = 'center';
                
                const textX = zone.x + zone.width / 2;
                const textY = zone.y + zone.height / 2;
                
                // Fondo para el texto
                const textWidth = zonesContext.measureText(zone.name).width;
                zonesContext.fillStyle = 'rgba(255, 255, 255, 0.8)';
                zonesContext.fillRect(textX - textWidth/2 - 5, textY - 10, textWidth + 10, 20);
                
                // Texto
                zonesContext.fillStyle = '#000';
                zonesContext.fillText(zone.name, textX, textY + 3);
            }
        }

        // Redibujar todas las zonas guardadas
            function redrawSavedZones() {
            try {
                savedZones.forEach(zone => {
                    drawZone(zone);
                });
                
                // Dibujar zona actual si existe
                if (currentZone) {
                    drawZone(currentZone);
                }
            } catch (error) {
                console.error('Error redibujando zonas:', error);
            }
        }

        // Actualizar vista previa del color
        function updateColorPreview() {
            const color = document.getElementById('zoneColor').value;
            document.getElementById('zoneColorPreview').style.backgroundColor = color;
            
            // Redibujar si hay zona actual
            if (currentZone) {
                currentZone.color = color;
                drawMapBackground();
            }
        }

        // Limpiar zona actual
        function clearCurrentZone() {
            currentZone = null;
            zonePoints = [];
            currentPointIndex = 0;
            isDrawingZone = false;
            
            document.getElementById('saveZoneBtn').disabled = true;
            document.getElementById('clearZoneBtn').disabled = true;
            document.getElementById('zoneName').value = '';
            
            if (zonesCanvas) {
                zonesCanvas.classList.remove('zone-drawing');
                drawMapBackground();
            }
            
            updateZoneStatus('Listo para crear zonas. Haz clic para empezar.', 'info');
        }

        // Guardar zona actual
        async function saveCurrentZone() {
            if (!currentZone) return;
            
            const name = document.getElementById('zoneName').value.trim();
            if (!name) {
                updateZoneStatus('Debes asignar un nombre a la zona', 'error');
                return;
            }
            
            currentZone.name = name;
            currentZone.id = Date.now(); // ID temporal
            
            try {
                // Preparar datos para enviar al servidor
                const zoneData = {
                    name: currentZone.name,
                    color: currentZone.color,
                    type: currentZone.type || 'polygon'
                };

                // Enviar datos seg√∫n el tipo de zona
                if (currentZone.type === 'polygon' && currentZone.points) {
                    // Zona poligonal con 4 puntos
                    zoneData.points = currentZone.points;
                } else if (currentZone.x !== undefined) {
                    // Zona rectangular legacy - convertir a puntos
                    zoneData.points = [
                        { x: currentZone.x, y: currentZone.y },
                        { x: currentZone.x + currentZone.width, y: currentZone.y },
                        { x: currentZone.x + currentZone.width, y: currentZone.y + currentZone.height },
                        { x: currentZone.x, y: currentZone.y + currentZone.height }
                    ];
                    zoneData.type = 'polygon';
                }

                // Guardar en base de datos
                const response = await fetch('/api/zones', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(zoneData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    currentZone.id = result.id;
                    
                    // Agregar a zonas guardadas
                    savedZones.push(currentZone);
                    
                    // Actualizar lista visual
                    updateZonesList();
                    
                    // Limpiar zona actual
                    clearCurrentZone();
                    
                    updateZoneStatus('Zona guardada correctamente', 'success');
                } else {
                    throw new Error('Error al guardar zona');
                }
            } catch (error) {
                console.error('Error:', error);
                updateZoneStatus('Error al guardar zona', 'error');
            }
        }

        // Cargar zonas guardadas desde la base de datos
        async function loadSavedZones() {
            try {
                const response = await fetch('/api/zones');
                if (response.ok) {
                    savedZones = await response.json();
                    updateZonesList();
                    if (zonesCanvas) {
                        drawMapBackground();
                    }
                } else {
                    console.error('Error al cargar zonas');
                }
            } catch (error) {
                console.error('Error:', error);
            }
        }

        // Actualizar lista de zonas
        function updateZonesList() {
            const container = document.getElementById('savedZonesList');
            
            if (savedZones.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No hay zonas guardadas</div>';
                return;
            }
            
            container.innerHTML = savedZones.map(zone => {
                // Determinar informaci√≥n de la zona seg√∫n su tipo
                let zoneInfo = '';
                if (zone.type === 'polygon' && zone.points && zone.points.length === 4) {
                    zoneInfo = `Pol√≠gono (4 puntos)`;
                } else if (zone.width !== undefined && zone.height !== undefined) {
                    zoneInfo = `${zone.width.toFixed(0)}√ó${zone.height.toFixed(0)} px`;
                } else {
                    zoneInfo = 'Zona personalizada';
                }
                
                return `
                    <div class="zone-item">
                        <div class="zone-color-indicator" style="background-color: ${zone.color}"></div>
                        <div class="zone-info">
                            <div class="zone-name">${zone.name}</div>
                            <div class="zone-coords">${zoneInfo}</div>
                        </div>
                        <button class="zone-delete" onclick="deleteZone(${zone.id})">üóëÔ∏è</button>
                    </div>
                `;
            }).join('');
        }

        // Eliminar zona
        async function deleteZone(zoneId) {
            if (!confirm('¬øEst√°s seguro de que deseas eliminar esta zona?')) return;
            
            try {
                const response = await fetch(`/api/zones/${zoneId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    // Remover de array local
                    savedZones = savedZones.filter(zone => zone.id !== zoneId);
                    
                    // Actualizar interfaz
                    updateZonesList();
                    drawMapBackground();
                    
                    updateZoneStatus('Zona eliminada correctamente', 'success');
                } else {
                    throw new Error('Error al eliminar zona');
                }
            } catch (error) {
                console.error('Error:', error);
                updateZoneStatus('Error al eliminar zona', 'error');
            }
        }

        // Actualizar estado/mensaje del sistema de zonas
        function updateZoneStatus(message, type) {
            const statusElement = document.getElementById('zoneStatus');
            statusElement.textContent = message;
            statusElement.className = `zone-status zone-status-${type}`;
            statusElement.style.display = 'block';
        }

        // Event listener para cerrar modal al hacer clic fuera
        window.addEventListener('click', (event) => {
            if (event.target === zonesModal) {
                closeZonesModal();
            }
        });

        // Event listener para redimensionar canvas cuando cambie el tama√±o de ventana
        window.addEventListener('resize', () => {
            if (zonesModal && zonesModal.style.display === 'block' && zonesCanvas) {
                setTimeout(() => {
                    resizeZonesCanvas();
                    drawMapBackground();
                }, 100);
            }
        });

        // ========== SISTEMA DE NAVEGACI√ìN POR ZONAS ==========
        
        // Variables para navegaci√≥n por zonas
        let availableZones = [];

        // Cargar zonas disponibles desde el servidor
        async function loadAvailableZones() {
            try {
                updateZoneNavStatus('Cargando zonas...', 'navigating');
                
                const response = await fetch('/api/robot/zones?robot_id=roberto');
                const data = await response.json();
                
                if (data.success && data.zones) {
                    availableZones = data.zones;
                    updateZoneSelector();
                    updateZoneNavStatus(`${data.zones_count} zonas cargadas`, 'ready');
                    addLog(`‚úÖ Cargadas ${data.zones_count} zonas disponibles`);
                } else {
                    throw new Error(data.error || 'Error al cargar zonas');
                }
            } catch (error) {
                console.error('Error cargando zonas:', error);
                updateZoneNavStatus('Error cargando zonas', 'error');
                addLog(`‚ùå Error cargando zonas: ${error.message}`);
            }
        }

        // Actualizar el selector de zonas con las zonas disponibles
        function updateZoneSelector() {
            const zoneSelect = document.getElementById('zoneSelect');
            zoneSelect.innerHTML = '<option value="">Seleccionar zona...</option>';
            
            availableZones.forEach(zone => {
                const option = document.createElement('option');
                option.value = zone.id;
                option.textContent = `${zone.name} (${zone.type})`;
                option.dataset.zone = JSON.stringify(zone);
                zoneSelect.appendChild(option);
            });
            
            // Habilitar el selector
            zoneSelect.disabled = availableZones.length === 0;
            
            // Event listener para cambios en la selecci√≥n
            zoneSelect.onchange = function() {
                const selectedOption = this.options[this.selectedIndex];
                if (selectedOption.dataset.zone) {
                    const zone = JSON.parse(selectedOption.dataset.zone);
                    showZoneInfo(zone);
                    document.getElementById('goToZoneBtn').disabled = false;
                } else {
                    hideZoneInfo();
                    document.getElementById('goToZoneBtn').disabled = true;
                }
            };
        }

        // Mostrar informaci√≥n de la zona seleccionada
        function showZoneInfo(zone) {
            const zoneInfo = document.getElementById('selectedZoneInfo');
            
            document.getElementById('zoneInfoName').textContent = zone.name;
            document.getElementById('zoneInfoType').textContent = zone.type || 'Pol√≠gono';
            
            // Calcular y mostrar el centro de la zona
            let centerText = 'Calculando...';
            if (zone.bounds && zone.bounds.center) {
                centerText = `(${zone.bounds.center.x.toFixed(2)}, ${zone.bounds.center.y.toFixed(2)})`;
            } else if (zone.bounds) {
                const centerX = zone.bounds.x + zone.bounds.width / 2;
                const centerY = zone.bounds.y + zone.bounds.height / 2;
                centerText = `(${centerX.toFixed(2)}, ${centerY.toFixed(2)})`;
            }
            
            document.getElementById('zoneInfoCenter').textContent = centerText;
            document.getElementById('navigationStatus').textContent = 'Listo para navegar';
            
            zoneInfo.style.display = 'block';
        }

        // Ocultar informaci√≥n de la zona
        function hideZoneInfo() {
            document.getElementById('selectedZoneInfo').style.display = 'none';
            document.getElementById('navigationStatus').textContent = 'Listo';
        }

        // Navegar a la zona seleccionada
        async function navigateToZone() {
            const zoneSelect = document.getElementById('zoneSelect');
            const selectedOption = zoneSelect.options[zoneSelect.selectedIndex];
            
            if (!selectedOption.dataset.zone) {
                addLog('‚ùå No hay zona seleccionada');
                return;
            }
            
            const zone = JSON.parse(selectedOption.dataset.zone);
            
            try {
                updateZoneNavStatus('Navegando a zona...', 'navigating');
                document.getElementById('navigationStatus').textContent = 'Navegando...';
                document.getElementById('goToZoneBtn').disabled = true;
                
                addLog(`üöÄ Iniciando navegaci√≥n a zona: ${zone.name}`);
                
                // Verificar conexi√≥n ROS antes de continuar
                if (!ros || !ros.isConnected) {
                    throw new Error('No hay conexi√≥n con ROS Bridge');
                }
                
                // Calcular coordenadas de destino (centro de la zona)
                let targetX, targetY;
                if (zone.bounds && zone.bounds.center) {
                    targetX = zone.bounds.center.x;
                    targetY = zone.bounds.center.y;
                } else if (zone.bounds) {
                    targetX = zone.bounds.x + zone.bounds.width / 2;
                    targetY = zone.bounds.y + zone.bounds.height / 2;
                } else {
                    throw new Error('No se encontraron coordenadas v√°lidas para la zona');
                }
                
                // Enviar comando de navegaci√≥n al robot via ROS
                await sendNavigationGoal(targetX, targetY, zone.name);
                
                addLog(`‚úÖ Comando de navegaci√≥n enviado: (${targetX.toFixed(2)}, ${targetY.toFixed(2)})`);
                updateZoneNavStatus(`Navegando a: ${zone.name}`, 'navigating');
                document.getElementById('navigationStatus').textContent = 'En tr√°nsito...';
                
                // Simular llegada despu√©s de 10 segundos como fallback
                setTimeout(() => {
                    const currentStatus = document.getElementById('navStatusText').textContent;
                    if (currentStatus.includes('Navegando a:')) {
                        updateZoneNavStatus(`Llegada a: ${zone.name}`, 'arrived');
                        document.getElementById('navigationStatus').textContent = 'Llegada exitosa';
                        document.getElementById('goToZoneBtn').disabled = false;
                        addLog(`üéØ Robot lleg√≥ a zona: ${zone.name}`);
                    }
                }, 10000);
                
            } catch (error) {
                console.error('Error navegando a zona:', error);
                updateZoneNavStatus('Error en navegaci√≥n', 'error');
                document.getElementById('navigationStatus').textContent = 'Error';
                document.getElementById('goToZoneBtn').disabled = false;
                addLog(`‚ùå Error navegando a zona: ${error.message}`);
                
                // Mostrar informaci√≥n adicional del error en la consola
                if (error.stack) {
                    console.error('Stack trace completo:', error.stack);
                }
            }
        }

        // Enviar objetivo de navegaci√≥n al robot via ROS usando el topic /move_base_simple/goal
        async function sendNavigationGoal(x, y, zoneName) {
            return new Promise((resolve, reject) => {
                try {
                    // Verificar conexi√≥n ROS
                    if (!ros || !ros.isConnected) {
                        throw new Error('Conexi√≥n ROS no disponible');
                    }
                    
                    // Crear el t√≥pico para enviar objetivos de navegaci√≥n
                    const moveBaseGoalTopic = new ROSLIB.Topic({
                        ros: ros,
                        name: '/move_base_simple/goal',
                        messageType: 'geometry_msgs/PoseStamped'
                    });
                    
                    // Crear el mensaje del objetivo
                    const goalMessage = new ROSLIB.Message({
                        header: {
                            frame_id: 'map',
                            stamp: {
                                sec: Math.floor(Date.now() / 1000),
                                nanosec: (Date.now() % 1000) * 1000000
                            }
                        },
                        pose: {
                            position: {
                                x: x,
                                y: y,
                                z: 0.0
                            },
                            orientation: {
                                x: 0.0,
                                y: 0.0,
                                z: 0.0,
                                w: 1.0
                            }
                        }
                    });
                    
                    // Publicar el mensaje
                    moveBaseGoalTopic.publish(goalMessage);
                    
                    addLog(`üì° Objetivo publicado en /move_base_simple/goal`);
                    addLog(`üìç Coordenadas: x=${x.toFixed(3)}, y=${y.toFixed(3)}`);
                    
                    // Resolver la promesa despu√©s de un peque√±o delay
                    setTimeout(() => {
                        resolve({
                            success: true,
                            message: `Navegaci√≥n iniciada hacia ${zoneName}`,
                            coordinates: { x, y }
                        });
                    }, 500);
                    
                } catch (error) {
                    addLog(`‚ùå Error enviando objetivo: ${error.message}`);
                    reject(error);
                }
            });
        }

        // Actualizar el estado visual del sistema de navegaci√≥n por zonas
        function updateZoneNavStatus(message, status) {
            const statusElement = document.getElementById('navStatusText');
            const indicatorElement = document.getElementById('navStatusIndicator');
            
            statusElement.textContent = message;
            
            // Remover todas las clases de estado
            statusElement.classList.remove('nav-status-ready', 'nav-status-navigating', 'nav-status-arrived', 'nav-status-error');
            
            // Agregar clase apropiada
            if (status) {
                statusElement.classList.add(`nav-status-${status}`);
            }
        }

        // Inicializar sistema de navegaci√≥n a zonas cuando se carga la p√°gina
        function initZoneNavigation() {
            // Cargar zonas disponibles
            loadAvailableZones();
            
            // Configurar estado inicial
            updateZoneNavStatus('Sistema de navegaci√≥n listo', 'ready');
            
            addLog('üéØ Sistema de navegaci√≥n a zonas inicializado');
        }

    </script>
    <script src="navigation.js"></script>
</body>
</html>
